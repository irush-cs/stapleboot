#!/usr/bin/perl -w

#
# Copyright (C) 2007-2011 Hebrew University Of Jerusalem, Israel
# See the LICENSE file.
#
# Author: Yair Yarom <irush@cs.huji.ac.il>
#

use warnings;
use strict;
use English;
use Getopt::Long;

BEGIN {
    my $file = $0;
    while (-l $file) {
        my $link = readlink $file;
        if ($link !~ m/^\//) {
            (my $dir) = $file =~ m,^(.*)/[^/]*$,;
            $file = "$dir/$link";
        } else {
            $file = $link;
        }
    }
    $file =~ m:^(.*)/[^/]*$:;
    push @INC, "$1/../lib/";
}

use Staple;
use Staple::Misc;
use Staple::DBFactory;
use Staple::Hangman;
use Staple::Template;
use Staple::Script;
use Staple::Autogroup;
use Staple::Configuration;
use Term::ReadLine;
use Term::ANSIColor qw(:constants);
use Net::DNS;

my $historyFile = "$ENV{HOME}/.staplectl_history";
my $distribution = "";
my $input;
my $attribs;
my $echooff = 0;
my $singleCommand = "";
my @dnsHostList = (); # for ah completion and warning
my $db;
my $lastCommand = "";

my %commands = (
                ac => \&ac,
                ad => \&ad,
                ag => \&ag,
                ah => \&ah,
                rc => \&rc,
                rd => \&rd,
                rg => \&rg,
                rh => \&rh,
                gm => \&gm,
                am => \&am,
                rm => \&rm,
                gt => \&gtm,
                at => \&at,
                al => \&al,
                rt => \&rt,
                ut => \&ut,
                gs => \&gs,
                as => \&as,
                rs => \&rs,
                us => \&us,
                ga => \&ga,
                aa => \&aa,
                ra => \&ra,
                ua => \&ua,
                cc => \&cc,
                cs => \&cs,
                ct => \&ct,
                ca => \&ca,

                act => \&act,
                adt => \&adt,
                agt => \&agt,
                aht => \&aht,
                ahg => \&ahg,
                adg => \&adg,
                rdg => \&rdg,
                agg => \&agg,
                rgg => \&rgg,
                gac => \&gac,
                gad => \&gad,
                gag => \&gag,
                gah => \&gah,
                gct => \&gct,
                gdt => \&gdt,
                ggt => \&ggt,
                gdg => \&gdg,
                ggg => \&ggg,
                ght => \&ght,
                ghg => \&ghg,
                rct => \&rct,
                uct => \&uct,
                ugt => \&ugt,
                rdt => \&rdt,
                udt => \&udt,
                rgt => \&rgt,
                rht => \&rht,
                uht => \&uht,
                rhg => \&rhg,
                ggc => \&ggc,
                ghc => \&ghc,
                gdc => \&gdc,
                ahc => \&ahc,
                adc => \&adc,
                agc => \&agc,
                rhc => \&rhc,
                rdc => \&rdc,
                rgc => \&rgc,
                gts => \&gts,
                gss => \&gss,
                gas => \&gas,
                ghi => \&ghi,
                ggi => \&ggi,
                gci => \&gci,
                gdi => \&gdi,
                whg => \&whg,
                whc => \&whc,
                wht => \&wht,
                gdv => \&gdv,
                sdv => \&sdv,
                acc => \&acc,
                gcc => \&gcc,
                rcc => \&rcc,
                ghn => \&ghn,
                shn => \&shn,
                sgn => \&sgn,
                ggn => \&ggn,
                sdn => \&sdn,
                gdn => \&gdn,
                scn => \&scn,
                gcn => \&gcn,

                uact => \&uact,
                uagt => \&uagt,
                uaht => \&uaht,
                uadt => \&uadt,

                sd  => \&sd,
                sync => \&syncctl,

                ndb     => \&ndb,
                quit    => \&quit,
                help    => \&help,
                setdb   => \&setdb,
                getdb   => \&getdb,
                hangman => \&hangman,
                debug   => \&debugOn,
                undebug => \&debugOff,

                bad => \&bad,
                " " => \&empty,
               );

my %commandMap = (
                  h                                => "help",
                  q                                => "quit",
                  e                                => "quit",
                  "?"                              => "help",

                  ac                               => "ac",
                  ad                               => "ad",
                  ag                               => "ag",
                  ah                               => "ah",
                  rc                               => "rc",
                  rd                               => "rd",
                  rg                               => "rg",
                  rh                               => "rh",
                  gm                               => "gm",
                  am                               => "am",
                  rm                               => "rm",
                  gt                               => "gt",
                  at                               => "at",
                  al                               => "al",
                  rt                               => "rt",
                  ut                               => "ut",
                  gs                               => "gs",
                  as                               => "as",
                  rs                               => "rs",
                  us                               => "us",
                  ga                               => "ga",
                  aa                               => "aa",
                  ra                               => "ra",
                  ua                               => "ua",
                  cc                               => "cc",
                  cs                               => "cs",
                  ct                               => "ct",
                  ca                               => "ca",

                  act                              => "act",
                  adt                              => "adt",
                  agt                              => "agt",
                  aht                              => "aht",
                  ahg                              => "ahg",
                  adg                              => "adg",
                  rdg                              => "rdg",
                  agg                              => "agg",
                  rgg                              => "rgg",
                  gac                              => "gac",
                  gad                              => "gad",
                  gag                              => "gag",
                  gah                              => "gah",
                  gct                              => "gct",
                  gdt                              => "gdt",
                  ggt                              => "ggt",
                  gdg                              => "gdg",
                  ggg                              => "ggg",
                  ght                              => "ght",
                  ghg                              => "ghg",
                  rct                              => "rct",
                  uct                              => "uct",
                  ugt                              => "ugt",
                  rdt                              => "rdt",
                  udt                              => "udt",
                  rgt                              => "rgt",
                  rht                              => "rht",
                  uht                              => "uht",
                  rhg                              => "rhg",
                  ggc                              => "ggc",
                  ghc                              => "ghc",
                  gdc                              => "gdc",
                  ahc                              => "ahc",
                  adc                              => "adc",
                  agc                              => "agc",
                  rhc                              => "rhc",
                  rdc                              => "rdc",
                  rgc                              => "rgc",
                  gts                              => "gts",
                  gss                              => "gss",
                  gas                              => "gas",
                  ghi                              => "ghi",
                  ggi                              => "ggi",
                  gci                              => "gci",
                  gdi                              => "gdi",
                  whg                              => "whg",
                  whc                              => "whc",
                  wht                              => "wht",
                  gdv                              => "gdv",
                  sdv                              => "sdv",
                  acc                              => "acc",
                  gcc                              => "gcc",
                  rcc                              => "rcc",
                  ghn                              => "ghn",
                  shn                              => "shn",
                  sgn                              => "sgn",
                  ggn                              => "ggn",
                  gdn                              => "gdn",
                  sdn                              => "sdn",
                  gcn                              => "gcn",
                  scn                              => "scn",
                  uact                             => "uact",
                  uagt                             => "uagt",
                  uaht                             => "uaht",
                  uadt                             => "uadt",

                  sd                               => "sd",
                  sdb                              => "setdb",
                  ndb                              => "ndb",
                  gdb                              => "getdb",
                  sync                             => "sync",

                  quit                             => "quit",
                  help                             => "help",
                  exit                             => "quit",
                  setdb                            => "setdb",
                  newdb                            => "ndb",
                  getdb                            => "getdb",
                  setdistribution                  => "sd",
                  getallhosts                      => "gah",
                  getallgroups                     => "gag",
                  getalldistributions              => "gad",
                  getallconfigurations             => "gac",
                  getconfigurationtokens           => "gct",
                  getgrouptokens                   => "ggt",
                  getdistributiontokens            => "gdt",
                  gethosttokens                    => "ght",
                  gethostgroups                    => "ghg",
                  getdistributiongroups            => "gdg",
                  getgroupgroups                   => "ggg",
                  addhost                          => "ah",
                  addgroup                         => "ag",
                  adddistribution                  => "ad",
                  addconfiguration                 => "ac",
                  adddistributiontoken             => "adt",
                  addhosttoken                     => "aht",
                  addhostgroup                     => "ahg",
                  addgrouptoken                    => "agt",
                  addconfigurationtoken            => "act",
                  removedistribution               => "rd",
                  removehost                       => "rh",
                  removegroup                      => "rg",
                  removeconfiguration              => "rc",
                  removedistributiontoken          => "rdt",
                  updatedistributiontoken          => "udt",
                  removeconfigurationtoken         => "rct",
                  updateconfigurationtoken         => "uct",
                  updateallconfigurationtokens     => "uact",
                  updateallgrouptokens             => "uagt",
                  updateallhosttokens              => "uaht",
                  updatealldistributiontokens      => "uadt",
                  updategroupgroup                 => "ugt",
                  removehosttoken                  => "rht",
                  updatehosttoken                  => "uht",
                  removegrouptoken                 => "rgt",
                  removehostgroup                  => "rhg",
                  adddistributiongroup             => "adg",
                  removedistributiongroup          => "rdg",
                  addgroupgroup                    => "agg",
                  removegroupgroup                 => "rgg",
                  getgroupconfigurations           => "ggc",
                  gethostconfigurations            => "ghc",
                  getdistributionconfigurations    => "gdc",
                  addhostconfiguration             => "ahc",
                  adddistributionconfiguration     => "adc",
                  addgroupconfiguration            => "agc",
                  removehostconfiguration          => "rhc",
                  removedistributionconfiguration  => "rdc",
                  removegroupconfiguration         => "rgc",
                  getmounts                        => "gm",
                  addmount                         => "am",
                  removeMount                      => "rm",
                  gettemplates                     => "gtm",
                  gettemplatesource                => "gts",
                  addtemplate                      => "at",
                  addlink                          => "al",
                  removetemplate                   => "rt",
                  updatetemplate                   => "ut",
                  getscripts                       => "gs",
                  getscriptsource                  => "gss",
                  addscript                        => "as",
                  removescript                     => "rs",
                  updatescript                     => "us",
                  getautos                         => "ga",
                  getautosource                    => "gas",
                  addauto                          => "aa",
                  removeauto                       => "ra",
                  updateauto                       => "ua",
                  gethostinfo                      => "ghi",
                  getgroupinfo                     => "ggi",
                  getconfigurationinfo             => "gci",
                  getdistributioninfo              => "gdi",
                  copyconfiguration                => "cc",
                  copyscript                       => "cs",
                  copyauto                         => "ca",
                  copytemplate                     => "ct",
                  hangman                          => "hangman",
                  debug                            => "debug",
                  undebug                          => "undebug",
                  whohasgroup                      => "whg",
                  whohasconfiguration              => "whc",
                  whohastoken                      => "wht",
                  getdistributionversion           => "gdv",
                  setdistributionversion           => "sdv",
                  addconfigurationconfiguration    => "acc",
                  getconfigurationconfigurations   => "gcc",
                  removeconfigurationconfiguration => "rcc",
                  gethostnote                      => "ghn",
                  sethostnote                      => "shn",
                  setgroupnote                     => "sgn",
                  getgroupnote                     => "ggn",
                  setdistributionnote              => "sdn",
                  getdistributionnote              => "gdn",
                  setconfigurationnote             => "scn",
                  getconfigurationnote             => "gcn",

                  badcommandorfilename             => "bad",
                  " "                              => " ",
                 );

my %commandCompletionMap =
  (h         => [\&help_completion],
   help      => [\&help_completion],
   "?"       => [\&help_completion],
   q         => [],
   exit      => [],
   quit      => [],
   ac        => [\&configuration_completion],
   ad        => [],
   ag        => [\&group_completion],
   ah        => [\&new_host_completion],
   rc        => [\&configuration_completion],
   rg        => [\&group_completion],
   rh        => [\&host_completion],
   rd        => [\&distribution_completion],
   gm        => [\&configuration_completion],
   am        => [\&configuration_completion, \&sign_dir_completion],
   rm        => [\&configuration_completion, \&mount_completion],
   gt        => [\&configuration_completion],
   at        => [\&configuration_completion],
   al        => [\&configuration_completion],
   rt        => [\&configuration_completion, \&template_stage_completion, \&template_completion],
   ut        => [\&configuration_completion, \&template_stage_completion, \&template_completion],
   gs        => [\&configuration_completion],
   as        => [\&configuration_completion],
   rs        => [\&configuration_completion, \&script_stage_completion, \&script_completion],
   us        => [\&configuration_completion, \&script_stage_completion, \&script_completion],
   ga        => [\&configuration_completion],
   aa        => [\&configuration_completion],
   ra        => [\&configuration_completion, \&auto_completion],
   ua        => [\&configuration_completion, \&auto_completion],
   act       => [\&configuration_completion],
   adt       => [\&distribution_completion],
   agt       => [\&group_completion],
   aht       => [\&host_completion],
   ahg       => [\&host_completion, \&group_completion],
   adg       => [\&group_completion],
   rdg       => [\&distribution_groups_completion],
   agg       => [\&group_completion, \&group_completion],
   rgg       => [\&group_completion, \&group_groups_completion],
   gac       => [],
   gad       => [],
   gag       => [],
   gah       => [],
   gct       => [\&configuration_completion],
   gdt       => [\&distribution_completion],
   ggt       => [\&group_completion],
   gdg       => [\&distribution_completion],
   ggg       => [\&group_completion],
   ght       => [\&host_completion],
   ghg       => [\&host_completion],
   rct       => [\&configuration_completion, \&configuration_tokens_completion],
   uct       => [\&configuration_completion, \&configuration_tokens_completion],
   uact      => [\&configuration_completion],
   uagt      => [\&group_completion],
   uaht      => [\&host_completion],
   uadt      => [\&distribution_completion],
   ugt       => [\&group_completion, \&group_tokens_completion],
   rdt       => [\&distribution_and_tokens_completion, \&distribution_tokens_completion],
   udt       => [\&distribution_and_tokens_completion, \&distribution_tokens_completion],
   rgt       => [\&group_completion, \&group_tokens_completion],
   rht       => [\&host_completion, \&host_tokens_completion],
   uht       => [\&host_completion, \&host_tokens_completion],
   rhg       => [\&host_completion, \&host_groups_completion],
   ggc       => [\&group_completion],
   ghc       => [\&host_completion],
   gdc       => [\&distribution_completion],
   ahc       => [\&host_completion, \&sign_configuration_completion],
   adc       => [\&sign_configuration_completion],
   agc       => [\&group_completion, \&sign_configuration_completion],
   rhc       => [\&host_completion, \&host_configurations_completion],
   rdc       => [\&distribution_configurations_completion],
   rgc       => [\&group_completion, \&group_configurations_completion],
   gts       => [\&configuration_completion, \&template_stage_completion, \&template_completion],
   gss       => [\&configuration_completion, \&script_stage_completion, \&script_completion],
   gas       => [\&configuration_completion, \&auto_completion],
   ghi       => [\&host_completion],
   ggi       => [\&group_completion], 
   gci       => [\&configuration_completion],
   gdi       => [\&distribution_completion],
   sd        => [\&distribution_completion],
   sdb       => [\&database_completion],
   gdb       => [],
   setdb     => [\&database_completion],
   ndb       => [\&database_completion],
   getdb     => [],
   sync      => [],
   cc        => [\&configuration_completion, \&distribution_completion, \&distribution_completion],
   cs        => [\&distribution_completion, \&dist_configuration_completion, \&script_stage_completion, \&script_completion, \&distribution_completion, \&dist_configuration_completion, \&script_stage_completion, \&script_completion],
   ca        => [\&distribution_completion, \&dist_configuration_completion, \&auto_completion, \&distribution_completion, \&dist_configuration_completion, \&auto_completion],
   ct        => [\&distribution_completion, \&dist_configuration_completion, \&template_stage_completion, \&template_completion, \&distribution_completion, \&dist_configuration_completion, \&template_stage_completion, \&template_completion],
   hangman   => [],
   debug     => [\&host_completion],
   undebug   => [\&host_completion],
   whg       => [\&group_completion],
   whc       => [\&configuration_completion],
   wht       => [],
   gdv       => [\&distribution_completion],
   sdv       => [\&version_completion, \&distribution_completion],
   acc       => [\&configuration_completion, \&sign_configuration_completion],
   gcc       => [\&configuration_completion],
   rcc       => [\&configuration_completion, \&configuration_configurations_completion],
   ghn       => [\&host_completion],
   shn       => [\&host_completion],
   sgn       => [\&group_completion],
   ggn       => [\&group_completion],
   sdn       => [\&distribution_completion],
   gdn       => [\&distribution_completion],
   gcn       => [\&configuration_completion],
   scn       => [\&configuration_completion],
  );

my %commandsHelp = (
                    ac => "
name: ac | add configuration
parameters: <configuration>

Adds <configuration> for the current distribution. Will create the parent
configurations if they don't exist.
",
                    ad => "
name: ad | add distribution
parameters: <distribution>

Adds <distribution> as a new distribution with an empty configuration tree.
",
                    ag => "
name: ag | add group
parameters: <group>

Adds <group> to the database. Will create the group parents, if they don't
exist.
",
                    ah => "
name: ah | add host
parameters: <host>

Adds <host> to the database.
",
                    rc => "
name: rc | remove configuration
parameters: <configuration>

Deletes <configuration> and all its sub-configuration. Will delete only
the configuration for the current distribution.
",
                    rd => "
name: rd | remove distribution
parameters: <distribution>

Deletes <distribution> from the staple database. Also deletes all the
configuration tree for <distribution>
",
                    rg => "
name: rg | remove group
parameters: <group>

Deletes <group> from the database, and all its subgroups.
",
                    rh => "
name: rh | remove host
parameters: <host>

Deletes <host> from the database.
",
                    gm => "
name: gm | get mounts
parameters: <configuration>

Prints the mount list of <configuration>
",
                    am => "
name: am | add mount
parameters: <configuration> {+|-}<mount> [<location>]

Adds <mount> to <configuration> at the end of the mount list, or at <location>
if given.
",
                    rm => "
name: rm | remove mount
parameters: <configuration> {+|-}<mount>

Removes the <mount> from <configuration>.
",
                    gt => "
name: gt | get templates
parameters: <configuration>

Prints <configuration>'s list of templates.
",
                    at => "
name: at | add template
parameters: <configuration>

Adds a new template to <configuration>. First an editor will be invoked, to add
the template. After it finishes, you'll be prompt for the template's parameters:
         uid: The uid of the template either uid or name, defaults to 0.
         gid: The gid of the template either gid or name, defaults to 0.
        mode: The permissions of the template, octal, defaults to 644.
       stage: when to copy the template: mount, sysinit or final.
 destination: where to copy the template to.
",
                    al => "
name: al | add link
parameters: <configuration>

Adds a new link to <configuration>. You'll be prompt for the link's parameters:
       stage: when to create the link: mount, sysinit or final.
      source: To where the link will point.
 destination: where to create the link.
",
                    rt => "
name: rt | remove template
parameters: <configuration> <stage> <template>

Deletes the given <template> from <configuration> at <stage>.
",
                    ut => "
name: ut | update template
parameters: <configuration> <stage> <template>
  stage: mount | sysinit | final

Updates <template> at <stage> of <configuration>.
",
                    gs => "
name: gs | get scripts
parameters: <configuration>

Prints the scripts list of <configuration>.
",
                    as => "
name: as | add script
parameters: <configuration>

Adds a new script to <configuration>. First an editor will be invoked, to add
the script. After it finishes, you'll be prompt for the script's parameters:
    name: name of the script
   stage: stage to run (auto, mount, sysinit, final)
location: when, relative to other scripts on this configuration, should it run.
critical: whether to stop the boot, if this script fails
  tokens: whether to do tokes substitution on this auto before running it
tokenScript: whether this script output new tokens values.
",
                    rs => "
name: rs | remove script
parameters: <configuration> <stage> {<script>|<location>}
  stage: auto | mount | sysinit | final

Deletes the <script> (or the <location>-th script) of stage <stage> from
<configuration>.
",
                    us => "
name: us | update script
parameters: <configuration> <stage> {<script>|<location>}
  stage: auto | mount | sysinit | final

Updates the <configuration>'s <script> in <stage>. if <location> is given,
update the <location>-th script in <configuration> (at <stage>).
An editor will be invoked, and later a prompt for each of the <script>'s
paramters.
",
                    ga => "
name: ga | get autos
parameters: <configuration>

Prints the <configuration>'s list of autos.
",
                    aa => "
name: aa | add auto
parameters: <configuration>

Add a new autogroup script to <configuration>. First an editor will be invoked,
to add the script. After it finishes, you'll be prompt for the auto parameters:
     name: name of the auto
 location: when, relative to other auto's on this configuration, should it run.
 critical: whether to stop the boot, if this auto fails
   tokens: whether to do tokes substitution on this auto before running it
",
                    ra => "
name: ra | remove auto
parameters: <configuration> <auto>

Deletes <auto> from <configuration>.
",
                    ua => "
name: ua | update auto
parameters: <configuration> <auto>

Updates the autogroup <auto>. An editor will be invoked, and after it finishes,
a prompt for each of the <auto> parameters will be given (defaults to current
state).
",
                    cc => "
name: cc | copy configuration
parameters: <configuration> <distribution1> <distribution2>

Copies the entire <configuration> from <distribution1> to <distribution2>. This
includes all child configurations.
",
                    cs => "
name: cs | copy script
parameters: <distribution1> <configuration1> <stage1> {<script1>|<location1>} <distribution2> [<configuration2> [<stage2> [<script2> [<location2>]]]]
  stage: auto | mount | sysinit | final

Copies a single script from <distribution1> to <distribution2>. <distribution1>
and <distribution2> can be the same to move a script between different
configurations in the same distribution. If any of the optional destination
parameters are missing, they're assumed to be the same is the source. If
location2 is omitted, the script will be copied at the end.
",
                    ca => "
name: ca | copy auto
parameters: <distribution1> <configuration1> {<auto1>|<location1>} <distribution2> [<configuration2> [<auto2> [<location2>]]]

Copies a single autogroup <auto1> from <distribution1> to <distribution2>.
<distribution1> and <distribution2> can be the same to move an autogroup
between different configurations in the same distribution. If any of the
optional destination parameters are missing, they're assumed to be the same as
in the source. If location2 is omitted, the autogroup will be copied at the
end.
",
                    ct => "
name: ct | copy template
parameters: <distribution1> <configuration1> <stage1> <template1> <distribution2> [<configuration2> [<stage2> [<template2>]]]
  stage: auto | mount | sysinit | final

Copies a single template from <distribution1> to <distribution2>. <distribution1>
and <distribution2> can be the same to move a template between different
configurations in the same distribution. If any of the optional destination
parameters are missing, they're assumed to be the same is the source. 
",
                    act => "
name: act | add configuration token
parameters: <configuration>

Adds a token to the <configuration>. You'll be prompt for token type (static,
regexp, or dynamic), key and value. value must end with a semicolon.
",
                    adt => "
name: adt | add distribution token
parameters: [<distribution>]

Adds a token to the (current) <distribution>. You'll be prompt for token type
(static, regexp, or dynamic), key and value. value must end with a semicolon.
",
                    agt => "
name: agt | add group token
parameters: <group>

Adds a token to the <group>. You'll be prompt for token type (static, regexp,
or dynamic), key and value. value must end with a semicolon.
",
                    aht => "
name: aht | add host token
parameters: <host>

Adds a token to the <host>. You'll be prompt for token type (static, regexp, or
dynamic), key and value. value must end with a semicolon.
",
                    ahg => "
name: ahg | add host group
parameters: <host> <group> [<location>]

Adds <group> to the <host>'s group list in <location>, or at the end if
<location> is omitted.
",
                    adg => "
name: adg | add distribution group
parameters: <group> [<location>]

Adds <group> to the current distribution's group list in <location>, or at the
end if <location> is omitted.
",
                    rdg => "
name: rdg | remove distribution group
parameters: <group>

Removes <group> from the current distribution's group list.
",
                    agg => "
name: agg | add group group
parameters: <group1> <group2> [<location>]

Adds <group2> to <group1>'s group list at <location>, or at the end if
<location> is omitted.
",
                    rgg => "
name: rgg | remove group group
parameters: <group1> <group2>

Removes <group2> from <group1>'s group list
",
                    gac => "
name: gac | get all configurations
parameters: [<pattern>]
  <pattern>: perl regular expression

Prints a list of all configurations in the current distribution. If pattern is
given, print only configurations that match it.
",
                    gad => "
name: gad | get all distributions

Prints a list of all distribution. The current distribution is marked with (*).
",
                    gag => "
name: gag | get all groups
parameters: [<pattern>]
  <pattern>: perl regular expression

Prints a list of all groups. If <pattern> is given, prints only groups that
match it.
",
                    gah => "
name: gah | get all hosts
parameters: [<pattern>]
  <pattern>: perl regular expression

Prints a list of all hosts. If <pattern> is given, prints only hosts the match
it.
",
                    gct => "
name: gct | get configuration tokens
parameters: <configuration>

Prints all the tokens for <configuration> (not including parents)
",
                    gdt => "
name: gdt | get distribution tokens
parameters: [<distribution>]

Prints all the tokens for (current) <distribution> (not descending into groups
or configurations).
",
                    ggt => "
name: ggt | get group tokens
parameters: <group>

Prints all the tokens for <group> (not descending into attached groups,
configurations, or parents).
",
                    gdg => "
name: gdg | get distribution groups
parameters: [<distribution>]

Prints all the groups in the (current) <distribution>'s group list
",
                    ggg => "
name: ggg | get group groups
parameters: <group>

Prints all the groups in the <group>'s group list (not recursively).
",
                    ght => "
name: ght | get host tokens
parameters: <host>

Prints all the tokens for <host> (not descending into group or configurations).
",
                    ghg => "
name: ghg | get host groups
parameters: <host>

Prints all the groups in the <host>'s group list
",
                    rct => "
name: rct | remove configuration token
parameters: <configuration> <token>

Removes the <token> from the <configuration>'s tokens list.
",
                    uct => "
name: uct | update configuration token
parameters: <configuration> <token>

Updates the token <token> in <configuration>.
",
                    uact => "
name: uact | update all configuration tokens
parameters: <configuration>

Updates all the tokens in <configuration>.
",
                    rdt => "
name: remove distribution token
parameters: [<distribution>] <token>

Removes the <token> from the (current) <distribution>'s tokens list.
",
                    udt => "
name: update distribution token
parameters: [<distribution>] <token>

Updates the <token> in the (current) <distribution>.
",
                    uadt => "
name: uact | update all distribution tokens
parameters: [<distribution>]

Updates all the tokens in [the current] <distribution>.
",
                    rgt => "
name: remove group token
parameters: <group> <token>

Removes the <token> from the <group>'s tokens.
",
                    ugt => "
name: update group token
parameters: <group> <token>

Updates <token> in <group>.
",
                    uagt => "
name: uagt | update all group tokens
parameters: <group>

Updates all the tokens in <group>.
",
                    rht => "
name: remove host token
parameters: <host> <token>

Removes the <token> from the <host>'s tokens.
",
                    uht => "
name: update host token
parameters: <host> <token>

Updates <token> in <host>.
",
                    uaht => "
name: uact | update all host tokens
parameters: <host>

Updates all the tokens in <host>.
",
                    rhg => "
name: rhg | remove host group
parameters: <host> <group>

Removes the <group> from the <host>'s group list.
",
                    ggc => "
name: ggc | get group configurations
parameters: <group>

Prints the list of configurations (active and inactive) for the given
<group>. Also prints the configurations for the <group>'s parents
",
                    ghc => "
name: ghc | get host configurations
parameters: <host>

Prints the list of configurations (active and inactive) for the given <host>.
  ",
                    ghn => "
name: ghn | get host note
parameters: <host>

Prints the <host>'s note  
  ",
                    shn => "
name: shn | set host note
parameters: <host> <note>

Sets <host> note to <note>
  ",
                    sgn => "
name: sgn | set group note
parameters: <group> <note>

Sets <group> note to <note>
  ",
                    ggn => "
name: ggn | get group note
parameters: <group>

Prints the <group>'s note  
  ",
                    scn => "
name: scn | set configuration note
parameters: <configuration> <note>

Sets <configuration> note to <note>
  ",
                    gcn => "
name: gcn | get configuration note
parameters: <configuration>

Prints the <configuration>'s note  
  ",
                    gdn => "
name: sdn | set distribution note
parameters: <distribution> <note>

Sets <distribution> note to <note>
  ",
                    gdn => "
name: gdn | get distribution note
parameters: [<distribution>]

Prints the <group>'s note  
  ",
                    gdc => "
name: gdc | get distribution configurations
parameters: [<distribution>]

Prints the list of configurations (active and inactive) for the (current)
<distribution>.
",
                    ahc => "
name: ahc | add host configuration
parameters: <host> {+|-}<configuration> [<location>]

Adds the <configuration> (either active or inactive) to the <host>'s list of
configurations at <location>. If <location> is omitted, add to the end of the
list.
",
                    adc => "
name: adc | add distribution configuration
parameters: <distribution> {+|-}<configuration> [<location>]

Adds the <configuration> (either active or inactive) to the <distribution>'s
list of configurations at <location>. If <location> is omitted, add to the end
of the list.
",
                    agc => "
name: agc | add group configuration
parameters: <group> {+|-}<configuration> [<location>]

Adds the <configuration> (either active or inactive) to the <group>'s list of
configurations at <location>. If <location> is omitted, add to the end of the
list.
",
                    rhc => "
name: rhc | remove host configuration
parameters: <host> {+|-}<configuration>

Removes the {+|-}<configuration> from the <host>'s list of
configurations.
",
                    rdc => "
name: rdc | remove distribution configuration
parameters: <distribution> {+|-}<configuration>

Removes the {+|-}<configuration> from the <distribution>'s list of
configurations.
",
                    rgc => "
name: rgc | remove group configuration
parameters: <group> {+|-}<configuration>

Removes the {+|-}<configuration> from the <group>'s list of configurations.
",
                    gts => "
name: gts | get template source
parameters: <configuration> <stage> <template>
  stage: auto | mount | sysinit | final

Prints the source of the <configurations>'s <template> at stage <stage>.
",
                    gss => "
name gss | get script source
parameters: <configuration> <stage> {<script>|<location>}
  stage: auto | mount | sysinit | final
  location: script location (integer)

Prints the source of the <configuration>'s <script> in <stage>.
<location> can be specified instead of <script>, denoting the <location>'s
script (according to their order in the <configuration>
",
                    gas => "
name: gas | get auto source
parameters: <configuration> <auto>

Prints the source of the <auto> script in <configuration>
",
                    ghi => "
name: ghi | get host info
parameters: <host>

Prints all available <host> information. Including tokens, groups, and
configurations (not recursively).
",
                    ggi => "
name: ggi | get group info
parameters: <group>

Prints all available <group> information. Includes tokens, groups,
and configuration (both locally defined and inherited).
",
                    gci => "
name: gci | get configuration info
parameters: <configuration>

Prints all available <configuration> information. Includes tokens, mounts,
templates, scripts, and autos (both locally defined and inherited).
",
                    gdi => "
name: gdi | get distribution info
parameters: [<distribution>]

Prints the (current) <distribution> tokens, groups and configurations.
",
                    whg => "
name: whg | who has group
parameters: <group>

Prints all hosts, distributions, and groups who directly uses the given
<group>, or one of it's descendents.
",
                    whc => "
name: whc | who has configuration
parameters: <configuration>

Prints all hosts, distributions, and groups who directly uses (either
activates or deactivates) the given <configuration>, or one of it's
descendents.
",
                    wht => "
name: wht | who has token
parameters: <token>

Prints all hosts, distributions, groups, and configurations who directly sets
the given <token>.
",

                    sd  => "
name: sd | set distribution
parameters: <distribution>

Sets the current distribution to <distribution>.
To get a list of all distributions, run 'gad'.

The default distribution is taken from the machine's root
file-system. i.e. either from /etc/staple/distribution, or by trying to parse
/proc/cmdline (if available).

If no current distribution is set, all distribution related commands will
probably not work.
",

                    sync => "
name: sync

Syncs between two staple databases. After calling sync you'll be prompt with
the two databases parameters (see sdb command for databases parameters).

",

                    quit    => "
name: quit | exit | q

Exits staplectl.
",
                    help    => "
General help:
name: help | h | ?
parameters: topic | command
  topic   - all | distributions | hosts | groups | configurations | others
  command - any command (run 'help all' to list all commands)

With topic, list all commands for that topic.
With command, gives help on that command.

All commands have abbreviations with their initialls (e.g. \"add host\" -> \"ah\")
Parameters are marked with <>
Parameters with [] are optional
Paraemters like {a|b} means can be the string a or the string b
Parameters like {<host>|<group>} means can be either a host or a group
",

                    setdb   => "TBD",
                    ndb     => "TBD",
                    getdb   => "
name: gdb | getdb

Get the current database info string (as given with the setdb command)
",
                    hangman => "
name: hangman
",
                    debug   => "
name: debug
parameters: <host>

Sets debugging mode to \"prompt\" on the specified <host>.
",
                    undebug => "
namd: undebug
parameters: <host>

Turns off debugging on the specified <host>.
",

                    helpdistributions  => "
Distribution commands:
  sd   | set distribution <dist>
  gad  | get all distributions
  gdi  | get distribution info <dist>
  ad   | add distribution <dist>
  rd   | remove distribution <dist>
  gdt  | get distribution tokens [<dist>]
  adt  | add distribution token [<dist>]
  rdt  | remove distribution token [<dist>] <token>
  udt  | update distribution token [<dist>] <token>
  uadt | update all distribution tokens [<dist>]
  gdg  | get distribution groups [<dist>]          
  adg  | add distribution group <group> [<location>]
  rdg  | remove distribution group <group>          
  gdc  | get distribution configurations [<dist>]   
  adc  | add distribution configuration {+|-}<conf> [<location>] 
  rdc  | remove distribution configuration {+|-}<conf>
  gdv  | get distribution version [<dist>]
  sdv  | set distribution version <version> [<dist>]
  sdn  | set distribution note <dist> <note>
  gdn  | get distribution note [<dist>]
",
                    helphosts          => "
Host commands:
  gah  | get all hosts [pattern]
  ghi  | get host info <host> 
  ah   | add host <host> 
  rh   | remove host <host> 
  ght  | get host tokens <host> 
  aht  | add host token <host>  
  rht  | remove host token <host> <token>
  uht  | update host token <host> <token>
  uaht | update all host tokens <host>
  ghg  | get host groups <host>
  ahg  | add host group <host> <group> [<location>]
  rhg  | remove host group <host> <group> 
  ghc  | get host configurations <host>
  ahc  | add host configuration <host> {+|-}<conf> [<location>] 
  rhc  | remove host configuration <host> {+|-}<conf>
  ghn  | get host note <host>
  shn  | set host note <host> <note>
",
                    helpgroups         => "
Group commands:
   gag  | get all groups [pattern]
   ggi  | get group info 
   ag   | add group <group>
   rg   | remove group <group>
   ggt  | get group tokens <group>
   agt  | add group token <group> 
   rgt  | remove group token <group> <token>
   ugt  | update group token <group> <token>
   uagt | update all group tokens <group>
   ggg  | get group groups <group> 
   agg  | add group group <group1> <group2> [<location>]
   rgg  | remove group group <group1> <group2> 
   ggc  | get group configurations <group> 
   agc  | add group configuration <group> {+|-}<conf> [<location>]
   rgc  | remove group configuration <group> {+|-}<conf>
   whg  | who has group <group>
   sgn  | set group note <group> <note>
   ggn  | get group note <group>
",
                    helpconfigurations => "
Configuration commands:
   gac  | get all configurations [<pattern>]
   gci  | get configuration info 
   ac   | add configuration <conf> 
   rc   | remove configuration <conf> 
   gct  | get configuration tokens <conf> 
   act  | add configuration token <conf>  
   rct  | remove configuration token <conf> <token>
   uct  | update configuration token <conf> <token>
   uact | update all configuration tokens <conf>
   gm   | get mounts <conf> 
   am   | add mount <conf> {+|-}<mount> [<location>]
   rm   | remove mount <conf> {+|-}<mount> 
   gt   | get templates <conf> 
   gts  | get template source <conf> <stage> <template>
   at   | add template <conf> 
   al   | add link <conf>
   rt   | remove template <conf> <stage> <template> 
   ut   | update template <conf> <stage> <template> 
   gs   | get scripts <conf> 
   gss  | get script source <conf> <stage> <script> 
   as   | add script <conf> 
   rs   | remove script <conf> <stage> <script> 
   us   | update script <conf> <stage> <script> 
   ga   | get autos <conf> 
   gas  | get auto source <conf> <auto> 
   aa   | add auto <conf> 
   ra   | remove auto <conf> <auto> 
   ua   | update auto <conf> <auto> 
   cc   | copy configuration <conf> <from> <to> 
   cs   | copy script <dist1> <conf1> <stage1> {<script>|<loc>} <dist2> [<conf2> [<stage2> [<script2> [<loc2>]]]]
   ca   | copy auto <dist1> <conf1> {<auto>|<loc>} <dist2> [<conf2> [<auto2> [<loc2>]]]
   ct   | copy template <dist1> <conf1> <stage1> {<template>|<loc>} <dist2> [<conf2> [<stage2> [<template2> [<loc2>]]]]
   whc  | who has configuration <conf>
   acc  | add configuration configuration <conf> {+|-}<conf> [<location>]
   gcc  | get configuration configurations <conf>
   rcc  | remove configuration configuration <conf1> {+|-}<conf2>
   scn  | set configuration note <conf> <note>
   gcn  | get configuration note <conf>
",
                    helpothers         => "
Other commands:
   h   | help [{<topic>|<command>}]
   q   | exit | quit
   sdb | set db <db> <params>
   ndb | new db <db> <params>
   gdb
   sync
   debug <host>
   undebug <host>
",
                    gdv => "
name: gdv | get distribution version
parameters: [<distribution>]

Gets <distribution>'s version.
",
                    sdv => "
name: sdv | set distribution version
parameters: <version> [<distribution>]

Sets <distribution>'s version to <version>. if <version> is omitted, use the
current staple version: $Staple::VERSION.

",
                    acc => "
name: acc | add configuration configuration
parameters: <configuration1> {+|-}<configuration2> [<location>]

Adds <configuration2> (either active or inactive) to <configuration1>'s list of
configurations at <location>. If <location> is omitted, add to the end of the
list.
",
                    gcc => "
name: gcc | get configuration configurations
parameters: <configuration>

Prints the list of configurations (active and inactive) for the given
<configuration>. Also prints the configurations for the <configuration>'s parents
",
                    rcc => "
name: rcc | remove configuration configuration
parameters: <configuration1> {+|-}<configuration2>

Removes {+|-}<configuration2> from <configuration1>'s list of configurations.
",
);

my @singleCommandCommands = ("ahc", "rhc", "gag", "ghc", "wht", "whc", "whg", "ghi", "ggi", "gci", "bad", "badcommandorfilename", "gt", "gdt", "gct", "gah", "gac", "gas", "gss", "gts", "gm", "ah", "gad", "ghn", "ggn", "gdn", "gcn", "debug", "undebug", "ndb", "ghg", "ght", "gdb", "ggg", "ggc", "ggt", "gcc", "ga", "gs");

sub help {
    my %topics = (a              => "helpall",
                  all            => "helpall",
                  d              => "helpdistributions",
                  distributions  => "helpdistributions",
                  h              => "helphosts",
                  hosts          => "helphosts",
                  g              => "helpgroups",
                  groups         => "helpgroups",
                  c              => "helpconfigurations",
                  configurations => "helpconfigurations",
                  o              => "helpothers",
                  others         => "helpothers",
                  " "            => "help");
    my $line = join " ", @_;
    (my $topic) = parseline($line);
    $topic = "help" unless $topic;
    if ($_[0]) {
        if (grep {$_ eq $_[0]} keys %topics) {
            $topic = $topics{$_[0]};
        } else {
            $topic = $commandMap{$topic};
        }
    } else {
        $topic = "help";
    }
    $topic = "bad" unless $topic;

    if ($topic eq "helpall") {
        help("distributions");
        help("hosts");
        help("groups");
        help("configurations");
        help("others");
    } elsif ($topic eq "bad") {
        print "No help for \"$line\" (yet)\n";
        print $commandsHelp{help};
    } elsif (defined $commandsHelp{$topic}) {
        print $commandsHelp{$topic};
    } else {
        print "No help for \"$topic\" (yet)\n";
    }
}

# checks if the given string is a range string
sub isRange {
    return 0 unless $_[0];
    return ($_[0] =~ m/^\D+\d+\.\.\d+$/ or index($_[0], ",") >= 0 ? 1 : 0);
}

# input: range list
# output: list
sub parseRange {
    my @results;
    my @removed;
    foreach my $splited (split /,/,$_[0]) {
        my $list;
        if ($splited =~ /^\^(.*)$/) {
            $list = \@removed;
            $splited = $1;
        } else {
            $list = \@results;
        }
        if ($splited =~ /(\D+)(\d+)\.\.(\d+)/) {
            foreach my $i ($2..$3) {
                push @$list, sprintf "$1%0".length($2)."i", $i;
            }
        } else {
            push @$list, $splited;
        }
    }
    @results = grep {my $a = $_; not grep {$_ eq $a} @removed} @results;
    return @results;
}

sub fillDnsHostList {
    my $res = new Net::DNS::Resolver;
    (my $domain) = $res->searchlist;
    my @hosts = map {$_->name} grep {$_->type eq "A"} $res->axfr($domain);
    @dnsHostList = map {$_ =~ s/\.$domain//; $_} @hosts;    
}

# input: prompt string, [default value]
sub prompt {
    my $prompt = shift;
    my $default = shift;
    my $string = "$prompt".(defined $default ? " [$default]" : "").": ";
    print $string;
    my $value = <>;
    chomp($value);
    $value = $default if defined $default and $value eq "";
    return $value;
}

# input: prompt string, [default value}
# output: 0/1
sub boolprompt {
    my $prompt = shift;
    my $default = shift;
    $default = "yes" if $default =~ m/^(?:1|y|yes)$/i;
    $default = "no" if $default =~ m/^(?:0|n|no)$/i;
    my $string = "$prompt".(defined $default ? " [$default]" : "").": ";
    print $string;
    my $value = <>;
    chomp($value);
    $value = $default if defined $default and $value =~ /^\s*$/;
    if ($value =~ m/^(?:yes|y|ok|1)$/i) {
        $value = 1;
    } else {
        $value = 0;
    }
    return $value;
}

# input: list of strings (sorted)
# no output, prints like tree
sub printTree {
    print join "\n", @_;
    print "\n";
    return;

    my @groups = @_;
    my @ancestors = ();
    while (my $current = shift @groups) {
        if (@ancestors) {
            my $father = pop @ancestors;
            if ($current =~ m/^$father(.*)/) {
                my @list = split "/",$father;
                print "     " x $#list;
                print $1;
                print "\n";
                push @ancestors, $father, $current;
            } else {
                unshift @groups, $current;
            }
        } else {
            print "$current\n";
            push @ancestors, $current;
        }
    }
}

sub quit {
    if ($input and $attribs->{history_base} and -w $historyFile) {
        $input->WriteHistory($historyFile);
        $input->history_truncate_file($historyFile, 1000);
    }
    exit 0;
}

sub bad {
    print "bad command or file name\n";
}

sub empty {
}

sub perror {
    my $err = shift;
    unless ($ENV{ANSI_COLORS_DISABLED}) {
        my $suffix = "";
        if ($err =~ m/\n$/) {
            $suffix = "\n";
            chop($err);
        }
        $err = RED.$err.RESET.$suffix;
    } 
    print STDERR $err;
}

sub gdv {
    my $dist = shift;
    $dist = $distribution unless $dist;
    my $version = $db->getDistributionVersion($dist);
    if (defined $version) {
        print "$version\n";
    } else {
        perror $db->{error}."\n";
    }
}

sub sdv {
    my $version = shift;
    my $dist = shift;
    $dist = $distribution unless defined $dist;
    $version = $Staple::VERSION unless defined $version;
    my $old = $db->setDistributionVersion($dist, $version);
    if (defined $old) {
        if ($old eq $version) {
            print "no change\n";
        } else {
            print "changed \"$dist\" version: $old -> $version\n";
        }
    } else {
        perror $db->{error}."\n";
    }
}

sub wht {
    my $token = shift;
    my $dist = shift;
    $dist = $distribution unless $dist;
    unless ($token) {
        print "Missing token key\n";
        return;
    }
    my $groups;
    my $configurations;
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        ($groups, $configurations) = $db->whoHasToken($token, $dist);
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
        return;
    }
    if (not defined $groups) {
        perror $db->{error}."\n";
        return;
    }
    foreach my $type ("host", "distribution", "group") {
        my @subset = grep {$_->type() eq $type} @$groups;
        if (@subset) {
            print "${type}s:\n";
            print join("", map {"  ".$_->name()."\n"} @subset);
            print "\n";
        }
    }

    if (@$configurations) {
        print "configurations ($dist):\n";
        print join("", map{"  ".$_->name()."\n"} @$configurations);
        print "\n";
    }
}

sub whc {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    (my $conf) = $db->getFullConfigurations([$configuration], $distribution);
    unless ($conf) {
        perror "No such configuration \"$configuration\" (for $distribution)\n";
        return;
    }

    my $agroups;
    my $ngroups;
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        ($agroups,$ngroups) = $db->whoHasConfiguration($configuration, $distribution);
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
        return;
    }
    if (not defined $agroups) {
        perror $db->{error}."\n";
        return;
    }
    foreach my $type ("host", "distribution", "group", "configuration") {
        my @asubset = grep {$_->type() eq $type} @$agroups;
        my @nsubset = grep {$_->type() eq $type} @$ngroups;
        if (@asubset or @nsubset) {
            print "${type}s:\n";
            print join("\n", map {"  (+) ".$_->name()} sort {$a->name() cmp $b->name()}  @asubset);
            print "\n" if @asubset;
            print join("\n", map {"  (-) ".$_->name()} sort {$a->name() cmp $b->name()}  @nsubset);
            print "\n\n";
        }
    }
}

sub whg {
    my $group = shift;
    unless ($group) {
        print "Missing group\n";
        return;
    }
    (my $groupr) = $db->getGroupsByName($group);
    unless ($groupr) {
        perror "No such group \"$group\"\n";
        return;
    }

    my @groups;
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        @groups = $db->whoHasGroup($group);
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
        return;
    }      
    if (@groups and not defined $groups[0]) {
        perror $db->{error}."\n";
        return;
    }
    foreach my $type ("host", "distribution", "group") {
        my @subset = grep {$_->type() eq $type} @groups;
        if (@subset) {
            print "${type}s:\n";
            print join("\n", map {"  ".$_->name()} sort {$a->name() cmp $b->name()} @subset);
            print "\n\n";
        }
    }
}

sub debugOn {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    my $group = $db->getHostGroup($host);
    unless ($group) {
        print "Host \"$host\" doesn't exist\n";
        return;
    }
    unless ($db->addTokens({"__STAPLE_DEBUG__" => {key => "__STAPLE_DEBUG__", value => "prompt", raw => "prompt", type => "static"}}, $group)) {
        perror $db->{error}."\n";
        return;
    }
    print "$host set to debug (prompt) mode\n";
}

sub debugOff {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    if (my $group = $db->getHostGroup($host)) {
        unless ($db->removeTokens(["__STAPLE_DEBUG__"], $group)) {
            perror $db->{error}."\n";
            return 0;
        }
        print "$host set to debug off\n";
    } else {
        print "Host \"$host\" doesn't exist\n";
    }
}

sub cc {
    my $configuration_name = shift;
    my $from = shift;
    my $to = shift;
    unless ($configuration_name) {
        print "Missing configurations\n";
        return;
    }
    unless ($from) {
        print "Missing source distribution\n";
        return;
    }
    unless ($to) {
        print "Missing destination distribution\n";
        return;
    }
    unless ($db->copyConfiguration($configuration_name, $from, $to)) {
        perror $db->{error}."\n";
        return;
    }
}

sub cs {
    (my $dist1, my $conf1, my $stage1, my $script1_name, my $dist2, my $conf2, my $stage2, my $script2_name, my $location2) = @_;
    
    # script1
    unless ($dist1) {
        perror "Missing source distribution\n";
        return;
    }
    (my @scripts1) = localgetscripts($conf1, $dist1);
    unless ($stage1) {
        perror "missing stage\n";
        return;
    }
    unless ($script1_name) {
        perror "missing script name\n";
        return;
    }
    unless (@scripts1) {
        perror "\"$conf1\" under \"$dist1\" has no scripts\n";
        return;
    }
    if (not defined $scripts1[0]) {
        return;
    }
    (my $script1) = grep {$_->stage() eq $stage1 and ($_->name() eq $script1_name or $_->order() eq $script1_name)} @scripts1;
    unless ($script1) {
        perror "No such script \"$script1_name\" in \"$conf1\" (under distribution \"$dist1\")\n";
        return;
    }

    # script2
    unless ($dist2) {
        perror "Missing destination distribution\n";
        return;
    }
    my $temp = $db->hasDistribution($dist2);
    if (not defined $temp) {
        perror "Can't get distribution list: ".$db->{error}."\n";
        return;
    } elsif ($temp == 0) {
        perror "No such distribution \"$dist2\"\n";
        return undef;
    }
    $conf2 = $conf1 unless $conf2;
    $stage2 = $stage1 unless $stage2;
    $script2_name = $script1_name unless $script2_name;

    if ($script2_name =~ m/^\d+$/) {
        perror "Must have a valid name for destination script\n";
        return;
    }

    if ($dist1 eq $dist2 and
        $conf1 eq $conf2) {
        print "To update a script use the \"update script\" command instead\n";
        return;
    }
    if ($conf1 eq $conf2 and $conf1 =~ m,^common/,) {
        print "Use \"update script\" for updating common script on the same configuration\n";
        return;
    }

    # from here, start changing stuff...
    (my $conf2full) = $db->getFullConfigurations([$conf2], $dist2);
    unless ($conf2full) {
        if ($db->addConfiguration($dist2, $conf2)) {
            print "Added configurations \"$conf2\" to \"$dist2\"\n";
            ($conf2full) = $db->getFullConfigurations([$conf2], $dist2);
        } else {
            perror $db->{error}."\n";
            return;
        }
    } else {
        (my @scripts2) = localgetscripts($conf2, $dist2);
        if (@scripts2 and $scripts2[0]) {
            (my $script2) = grep {$_->stage() eq $stage2 and ($_->name() eq $script2_name or $_->order() eq $script2_name)} @scripts2;
            if ($script2) {
                print "Removing previous script $script2_name in $conf2 of $dist2\n";
                unless ($db->removeScripts($script2)) {
                    perror $db->{error}."\n";
                    return;
                }
            }
        }
    }

    my %script = ();
    $script{name} = $script2_name;
    $script{source} = $script1->source();
    $script{configuration} = $conf2full;
    $script{stage} = $stage2;
    $script{order} = $location2;
    $script{order} = undef if $location2 and $script{order} !~ m/^\d+$/;
    $script{critical} = $script1->critical();
    $script{tokens} = $script1->tokens();
    $script{tokenScript} = $script1->tokenScript();
    perror $db->{error}."\n" unless ($db->addScripts(Staple::Script->new(\%script)));
}


sub ca {
    (my $dist1, my $conf1, my $auto1_name, my $dist2, my $conf2, my $auto2_name, my $location2) = @_;
    
    # auto1
    unless ($dist1) {
        perror "Missing source distribution\n";
        return;
    }
    (my @autos1) = localgetautos($conf1, $dist1);
    unless ($auto1_name) {
        perror "missing auto name\n";
        return;
    }
    unless (@autos1) {
        perror "\"$conf1\" under \"$dist1\" has no autos\n";
        return;
    }
    if (not defined $autos1[0]) {
        return;
    }
    (my $auto1) = grep {$_->name() eq $auto1_name or $_->order() eq $auto1_name} @autos1;
    unless ($auto1) {
        perror "No such auto \"$auto1_name\" in \"$conf1\" (under distribution \"$dist1\")\n";
        return;
    }

    # auto2
    unless ($dist2) {
        perror "Missing destination distribution\n";
        return;
    }
    my $temp = $db->hasDistribution($dist2);
    if (not defined $temp) {
        perror "Can't get distribution list: ".$db->{error}."\n";
        return;
    } elsif ($temp == 0) {
        perror "No such distribution \"$dist2\"\n";
        return undef;
    }
    $conf2 = $conf1 unless $conf2;
    $auto2_name = $auto1_name unless $auto2_name;

    if ($auto2_name =~ m/^\d+$/) {
        perror "Must have a valid name for destination auto\n";
        return;
    }

    if ($dist1 eq $dist2 and
        $conf1 eq $conf2) {
        print "To update a auto use the \"update auto\" command instead\n";
        return;
    }
    if ($conf1 eq $conf2 and $conf1 =~ m,^common/,) {
        print "Use \"update auto\" for updating common auto on the same configuration\n";
        return;
    }

    # from here, start changing stuff...
    (my $conf2full) = $db->getFullConfigurations([$conf2], $dist2);
    unless ($conf2full) {
        if ($db->addConfiguration($dist2, $conf2)) {
            print "Added configurations \"$conf2\" to \"$dist2\"\n";
            ($conf2full) = $db->getFullConfigurations([$conf2], $dist2);
        } else {
            perror $db->{error}."\n";
            return;
        }
    } else {
        (my @autos2) = localgetautos($conf2, $dist2);
        if (@autos2 and $autos2[0]) {
            (my $auto2) = grep {$_->name() eq $auto2_name or $_->order() eq $auto2_name} @autos2;
            if ($auto2) {
                print "Removing previous auto $auto2_name in $conf2 of $dist2\n";
                unless ($db->removeAutos($auto2)) {
                    perror $db->{error}."\n";
                    return;
                }
            }
        }
    }

    (my $auto2) = Staple::Autogroup->new($auto1);
    $auto2->name($auto2_name);
    $auto2->configuration($conf2full);
    $auto2->order(defined $location2 ? $location2 : -1);
    perror $db->{error}."\n" unless ($db->addAutos($auto2));
}

sub ct {
    (my $dist1, my $conf1, my $stage1, my $template1_dest, my $dist2, my $conf2, my $stage2, my $template2_dest) = @_;
    
    # script1
    unless ($dist1) {
        perror "Missing source distribution\n";
        return;
    }
    (my @templates1) = localgettemplates($conf1, $dist1);
    unless ($stage1) {
        perror "missing stage\n";
        return;
    }
    unless ($template1_dest) {
        perror "missing template\n";
        return;
    }
    unless (@templates1) {
        perror "\"$conf1\" under \"$dist1\" has no templates\n";
        return;
    }
    if (not defined $templates1[0]) {
        return;
    }
    (my $template1) = grep {$_->stage() eq $stage1 and $_->destination() eq $template1_dest} @templates1;
    unless ($template1) {
        perror "No such template \"$template1_dest\" in \"$conf1\" (under distribution \"$dist1\")\n";
        return;
    }

    # template2
    unless ($dist2) {
        perror "Missing destination distribution\n";
        return;
    }
    my $temp = $db->hasDistribution($dist2);
    if (not defined $temp) {
        perror "Can't get distribution list: ".$db->{error}."\n";
        return;
    } elsif ($temp == 0) {
        perror "No such distribution \"$dist2\"\n";
        return undef;
    }
    $conf2 = $conf1 unless $conf2;
    $stage2 = $stage1 unless $stage2;
    $template2_dest = $template1_dest unless $template2_dest;

    if ($dist1 eq $dist2 and
        $conf1 eq $conf2 and
        $stage1 eq $stage2 and
        $template1_dest eq $template2_dest) {
        print "To update a template use the \"update template\" command instead\n";
        return;
    }
    if ($conf1 eq $conf2 and
        $stage1 eq $stage2 and
        $template1_dest eq $template2_dest and
        $conf1 =~ m,^common/,) {
        print "Use \"update template\" for updating common template on the same configuration\n";
        return;
    }

    # from here, start changing stuff...
    (my $conf2full) = $db->getFullConfigurations([$conf2], $dist2);
    unless ($conf2full) {
        if ($db->addConfiguration($dist2, $conf2)) {
            print "Added configurations \"$conf2\" to \"$dist2\"\n";
            ($conf2full) = $db->getFullConfigurations([$conf2], $dist2);
        } else {
            perror $db->{error}."\n";
            return;
        }
    } else {
        (my @templates2) = localgettemplates($conf2, $dist2);
        if (@templates2 and $templates2[0]) {
            (my $template2) = grep {$_->stage() eq $stage2 and $_->destination() eq $template2_dest} @templates2;
            if ($template2) {
                print "Removing previous template $template2_dest in $conf2 of $dist2\n";
                unless ($db->removeTemplates($template2)) {
                    perror $db->{error}."\n";
                    return;
                }
            }
        }
    }

    (my $template2) = Staple::Template->new($template1);
    $template2->destination($template2_dest);
    $template2->configuration($conf2full);
    $template2->stage($stage2);
    perror $db->{error}."\n" unless ($db->addTemplates($template2));    
}

sub gdi {
    my $dist = shift;
    $dist = $distribution unless $dist;
    my $group;
    unless ($dist) {
        print "Distribution not set\n";
        return;
    }
    unless ($group = $db->getDistributionGroup($dist)) {
        print "Unknown distribution \"$dist\"\n";
        return;
    }
    print "Tokens:\n";
    gdt($dist);
    print "\nGroups:\n";
    gdg($dist);
    print "\nConfigurations:\n";
    gdc($dist);
    if (my $note = $db->getNote($group)) {
        print "\nNote:\n";
        print "$note\n";
    }
}

sub ghi {
    my $host = shift;
    my $hostg;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($hostg = $db->getHostGroup($host)) {
        print "No such host \"$host\"\n";
        return;
    }
    if (keys %{$db->getTokens($hostg)}) {
        print "Tokens:\n";
        ght($host);
    }
    if ($db->getGroupGroups($hostg)) {
        print "\nGroups:\n";
        ghg($host);
    }
    if ($db->getGroupConfigurations($hostg)) {
        print "\nConfigurations:\n";
        ghc($host);
    }
    if (my $note = $db->getNote($hostg)) {
        print "\nNote:\n";
        print "$note\n";
    }
}

sub ggi {
    my $group_name = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    (my $groupg) = $db->getGroupsByName($group_name);
    unless ($groupg) {
        print "No such group \"$group_name\"\n";
        return;
    }
    my @groups_names = splitData($group_name);
    my @groups = $db->getGroupsByName(@groups_names);
    foreach my $group (@groups) {
        print $group->name().":\n";
        print "-" x length($group->name());
        print "\n";
        #print "Path: $group->{path}\n";
        if (keys %{$db->getTokens($group)}) {
            print "Tokens:\n";
            printgctokens($group);
            print "\n";
        }
        my @groupsref = $db->getGroupGroups($group);
        if (@groupsref and not defined $groupsref[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            if (@groupsref) {
                print "Groups:\n";
                print join "\n", map {$_->name()} @groupsref;
                print "\n\n";
            }
        }
        my @configurations = $db->getGroupsConfigurations($group);
        if (@configurations and not defined $configurations[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            if (@configurations) {
                print "Configurations:\n";
                print "  ";
                print join "\n  ", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
                print "\n";
            }
        }
        if (my $note = $db->getNote($group)) {
            print "\nNote:\n";
            print "$note\n";
        }
        print "\n";
    }
}

sub gci {
    my $configuration_name = shift;
    unless ($configuration_name) {
        print "Missing configurations\n";
        return;
    }
    # remove +/- prefixes
    ($configuration_name) = Staple::Configuration->new({name => $configuration_name});
    unless (ref $configuration_name) {
        perror $configuration_name."\n";
        return;
    }
    $configuration_name = $configuration_name->name();
    (my $conf) = $db->getFullConfigurations([$configuration_name], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration_name\"\n";
        return;
    }
    my @configurations_names = splitData($configuration_name);
    foreach my $configuration_name (@configurations_names) {
        next if $configuration_name eq "common";
        print "$configuration_name\n";
        print "-" x length($configuration_name);
        (my $aconf) = $db->getFullConfigurations([$configuration_name], $distribution);
        my @configurations = $db->getConfigurationConfigurations($aconf);
        if (versionCompare($db->getDistributionVersion($distribution), "004") >= 0) {
            if (@configurations and not defined $configurations[0]) {
                perror $db->{error};
            } else {
                if (@configurations) {
                    print "\nConfigurations:\n";
                    print "  ";
                    print join "\n  ", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
                    print "\n";
                }
            }
        }
        print "\n";

        if (keys %{$db->getTokens($aconf)}) {
            print "Tokens:\n";
            gct($configuration_name);
        }
        if ($db->getMounts($aconf)) {
            print "Mounts:\n";
            gm($configuration_name);
        }
        if ($db->getTemplates($aconf)) {
            print "\nTemplates:\n";
            gtm($configuration_name);
        }
        if ($db->getScripts($aconf)) {
            print "\nScripts:\n";
            gs($configuration_name);
        }
        # why need to encapsulate with reference?!?!?, hint: it doesn't work otherwise...
        if (@{[$db->getAutos($aconf)]}) {
            print "\nAutos:\n";
            ga($configuration_name);
        }
        if (my $note = $db->getNote($aconf)) {
            print "\nNote:\n";
            print "$note\n";
        }
        print "\n";
    }
}

# input: filename
# output: 1 or undef
# edits filename
sub edit {
    my $file = shift;
    my $editor = $ENV{VISUAL};
    $editor = $ENV{EDITOR} unless $editor;
    $editor = "vi" unless $editor;
    unless (system("$editor $file") == 0) {
        print "Editor \"$editor\" failed\n";
        return undef;
    }
    return 1;
}

# input: configuration name, optional distribution
# output: list of autos
sub localgetautos {
    my $configuration = shift;
    my $dist = shift;
    $dist = $distribution unless $dist;
    unless ($configuration) {
        print "Missing configuration\n" unless $echooff;
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n" unless $echooff;
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $dist);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$dist\" distribution\n" unless $echooff;
        return undef;
    }
    my @autos = $db->getAutos($conf);
    if (@autos and not defined $autos[0]) {
        perror $db->{error}."\n" unless $echooff;
        return undef;
    }
    return @autos;
}

sub ga {
    (my @autos) = localgetautos(@_);
    if (@autos and $autos[0]) {
        print join "", map {"   ".$_->description()} sort {$a->order() <=> $b->order()} @autos;
    }
}

sub gas {
    my $configuration = shift;
    my $auto_name = shift;
    (my @autos) = localgetautos($configuration);
    unless ($auto_name) {
        print "Missing auto name/location\n";
        return;
    }
    if (@autos and $autos[0]) {
        my $auto;
        if ($auto_name =~ m/^\d+$/) {
            ($auto) = grep {$_->order() == $auto_name} @autos;
        } else {
            ($auto) = grep {$_->name() eq $auto_name} @autos;
        }
        unless ($auto) {
            print "No such auto \"$auto_name\" in \"$configuration\"\n";
            return;
        }
        my $data = $auto->data();
        if ($auto->error()) {
            print $auto->error()."\n";
            return;
        }
        if ($data !~ m/\n$/) {
            $data .= "\n(auto doesn't end with new line)\n";
        }
        print $data;
    } else {
        print "No such auto \"$auto_name\" in \"$configuration\"\n";
        return;
    }
}


sub aa {
    my $configuration = shift;
    unless ($configuration) {
        perror "Missing configuration\n";
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        perror "unknown configuration \"$configuration\"\n";
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        perror "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return undef;
    }
    my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
    if ($? != 0) {
        perror "Can't create temporary file on /tmp/\n";
        return;
    }    
    chomp $tmpFile;
    unless (edit($tmpFile)) {
        unlink $tmpFile;
        return;
    }
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        my %auto;
        $auto{name} = prompt "name";
        $auto{source} = $tmpFile;
        $auto{configuration} = $conf;
        $auto{order} = prompt "location", "end";
        $auto{order} = undef unless $auto{order} =~ m/^\d+$/;
        $auto{critical} = boolprompt "critical", "no";
        $auto{tokens} = boolprompt "tokens", "no";
        perror $db->{error}."\n" unless ($db->addAutos(Staple::Autogroup->new(\%auto)));
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
    }
    unlink $tmpFile;
}

sub ra {
    my $configuration = shift;
    my $auto_name = shift;
    (my @autos) = localgetautos($configuration);
    unless ($auto_name) {
        print "Missing auto\n";
        return;
    }
    if (@autos and $autos[0]) {
        (my $auto) = grep {$_->name() eq $auto_name or $_->order() eq $auto_name} @autos;
        unless ($auto) {
            print "No such auto \"$auto_name\" in \"$configuration\"\n";
            return;
        }
        unless ($db->removeAutos($auto)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such auto \"$auto_name\" in \"$configuration\"\n";
        return;
    }
}

sub ua {
    my $configuration = shift;
    my $auto_name = shift;
    (my @autos) = localgetautos($configuration);
    unless ($auto_name) {
        print "Missing auto\n";
        return;
    }
    if (@autos and $autos[0]) {
        (my $auto) = grep {$_->name() eq $auto_name or $_->order() eq $auto_name} @autos;
        unless ($auto) {
            print "No such auto \"$auto_name\" in \"$configuration\"\n";
            return;
        }
        my $data = $auto->data();
        if ($auto->error()) {
            print $auto->error()."\n";
            return;
        }
        my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
        if ($? != 0) {
            print "Can't create temporary file on /tmp/\n";
            return;
        }
        chomp $tmpFile;
        unless (open(FILE, ">$tmpFile")) {
            print "Can't open temporary file for writing $tmpFile: $!\n";
            unlink $tmpFile;
            return;
        }
        print FILE $data;
        close(FILE);
        unless (edit($tmpFile)) {
            unlink $tmpFile;
            return;
        }
        eval {
            local $SIG{INT} = sub {die "SIGINT"};
            my %newAuto;
            $newAuto{source} = $tmpFile;
            $newAuto{name} = prompt "name", $auto->name();
            $newAuto{order} = prompt "order", $auto->order();
            $newAuto{order} = undef unless $newAuto{order} =~ m/^\d+$/;
            $newAuto{critical} = boolprompt "critical", $auto->critical();
            $newAuto{tokens} = boolprompt "tokens", $auto->tokens();
            $newAuto{configuration} = $auto->configuration();
            print $db->{errro}."\n" unless ($db->removeAutos($auto));
            perror $db->{error}."\n" unless ($db->addAutos(Staple::Autogroup->new(\%newAuto)));
        };
        if ($@) {
            print "\n";
            print "$@" if index($@,"SIGINT") != 0;
        }
        unlink $tmpFile
    } else {
        print "No such auto \"$auto_name\" in \"$configuration\"\n";
        return;
    }
}

# input: configuration name, optional distribution name
# output: list of scripts or undef
sub localgetscripts {
    my $configuration = shift;
    my $dist = shift;
    $dist = $distribution unless $dist;
    unless ($configuration) {
        print "Missing configuration\n" unless $echooff;
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n" unless $echooff;
        return undef;
    }
    my @distributions = $db->getAllDistributions();
    if (@distributions and not defined $distributions[0]) {
        perror "Can't get distribution list: ".$db->{error}."\n";
        return undef;
    } elsif (not grep {$_ eq $dist} @distributions) {
        perror "No such distribution \"$dist\"\n";
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $dist);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$dist\" distribution\n" unless $echooff;
        return undef;
    }
    my @scripts = $db->getScripts($conf);
    if (@scripts and not defined $scripts[0]) {
        perror $db->{error}."\n" unless $echooff;
        return undef;
    }
    return @scripts;
}

sub rs {
    my $configuration = shift;
    my $stage = shift;
    my $script_name = shift;
    (my @scripts) = localgetscripts($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($script_name) {
        print "Missing script\n";
        return;
    }
    if (@scripts and $scripts[0]) {
        (my $script) = grep {$_->stage() eq $stage and ($_->name() eq $script_name or $_->order() eq $script_name)} @scripts;
        unless ($script) {
            print "No such script \"$script_name\" in \"$configuration\"\n";
            return;
        }
        unless ($db->removeScripts($script)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such script \"$script_name\" in \"$configuration\"\n";
        return;
    }
}

sub us {
    my $configuration = shift;
    my $stage = shift;
    my $script_name = shift;
    (my @scripts) = localgetscripts($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($script_name) {
        print "Missing script\n";
        return;
    }
    if (@scripts and $scripts[0]) {
        (my $script) = grep {$_->stage() eq $stage and ($_->name() eq $script_name or ($script_name =~ m/^\d+$/ and $_->order() == $script_name))} @scripts;
        unless ($script) {
            print "No such script \"$script_name\" in \"$configuration\"\n";
            return;
        }
        
        my $data = $script->data();
        if ($script->error()) {
            print $script->error()."\n";
            return;
        }

        my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
        if ($? != 0) {
            print "Can't create temporary file on /tmp/\n";
            return;
        }
        chomp $tmpFile;
        unless (open(FILE, ">$tmpFile")) {
            print "Can't open temporary file for writing $tmpFile: $!\n";
            unlink $tmpFile;
            return;
        }
        print FILE $data;
        close(FILE);
        unless (edit($tmpFile)) {
            unlink $tmpFile;
            return;
        }
        eval {
            local $SIG{INT} = sub {die "SIGINT"};
            my %newScript;
            $newScript{source} = $tmpFile;
            $newScript{name} = prompt "name", $script->name();
            do {
                $newScript{stage} = prompt "stage (auto, mount, sysinit, final)", $script->stage();
            } until ($newScript{stage} =~ m/^(?:auto|mount|sysinit|final)$/);
            $newScript{order} = prompt "order", $script->order();
            $newScript{order} = undef unless $newScript{order} =~ m/^\d+$/;
            $newScript{critical} = boolprompt "critical", $script->critical();
            $newScript{tokens} = boolprompt "tokens", $script->tokens();
            $newScript{tokenScript} = boolprompt "tokenScript", $script->tokenScript();
            $newScript{configuration} = $script->configuration();
            perror $db->{error}."\n" unless ($db->removeScripts($script));
            perror $db->{error}."\n" unless ($db->addScripts(Staple::Script->new(\%newScript)));
        };
        if ($@) {
            print "\n";
            print "$@" if index($@,"SIGINT") != 0;
        }
        unlink $tmpFile
    } else {
        print "No such script \"$script_name\" in \"$configuration\"\n";
        return;
    }
}

sub as {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n";
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return undef;
    }
    my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
    if ($? != 0) {
        print "Can't create temporary file on /tmp/\n";
        return;
    }    
    chomp $tmpFile;
    unless (edit($tmpFile)) {
        unlink $tmpFile;
        return;
    }
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        my %script;
        do {
            $script{name} = prompt "name";
        } until ($script{name});
        $script{source} = $tmpFile;
        $script{configuration} = $conf;
        do {
            $script{stage} = prompt "stage (auto, mount, sysinit, final)";
        } until ($script{stage} =~ m/^(?:auto|mount|sysinit|final)$/);
        $script{order} = prompt "location", "end";
        $script{order} = undef unless $script{order} =~ m/^\d+$/;
        $script{critical} = boolprompt "critical", "no";
        $script{tokens} = boolprompt "tokens", "no";
        $script{tokenScript} = boolprompt "tokenScript", "no";
        perror $db->{error}."\n" unless ($db->addScripts(Staple::Script->new(\%script)));
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
    }
    unlink $tmpFile
}

sub gss {
    my $configuration = shift;
    my $stage = shift;
    my $script_name = shift;
    (my @scripts) = localgetscripts($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($script_name) {
        print "Missing script name/location\n";
        return;
    }
    if (@scripts and $scripts[0]) {
        my $script;
        if ($script_name =~ m/^\d+$/) {
            ($script) = grep {$_->stage() eq $stage and $_->order() == $script_name} @scripts;
        } else {
            ($script) = grep {$_->stage() eq $stage and $_->name() eq $script_name} @scripts;
        }
        unless ($script) {
            print "No such script \"$script_name\" in \"$configuration\"\n";
            return;
        }
        my $data = $script->data();
        if ($script->error()) {
            print $script->error()."\n";
            return;
        }
        if ($data !~ m/\n$/) {
            $data .= "\n(script doesn't end with new line)\n";
        }
        print $data;
    } else {
        print "No such script \"$script_name\" in \"$configuration\"\n";
        return;
    }
}

sub gs {
    (my @scripts) = localgetscripts($_[0]);
    if (@scripts and $scripts[0]) {
        foreach my $stage ("auto", "mount", "sysinit", "final") {
            next unless grep {$_->stage() eq $stage} @scripts;
            print "  $stage:\n";
            print join "", map {"     ".$_->description()} sort {$a->order() <=> $b->order()} grep {$_->stage() eq $stage} @scripts;
        }
    }
}

# input: configuration name, optional distribution name
# output: list of templates
sub localgettemplates {
    my $configuration = shift;
    my $dist = shift;
    $dist = $distribution unless $dist;
    unless ($configuration) {
        print "Missing configuration\n" unless $echooff;
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n"  unless $echooff;
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $dist);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$dist\" distribution\n" unless $echooff;
        return undef;
    }
    my @templates = $db->getTemplates($conf);
    if (@templates and not defined $templates[0]) {
        perror $db->{error}."\n"  unless $echooff;
        return undef;
    }
    return @templates;
}

sub rt {
    my $configuration = shift;
    my $stage = shift;
    my $template_name = shift;
    (my @templates) = localgettemplates($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($template_name) {
        print "Missing Template\n";
        return;
    }
    if (@templates and $templates[0]) {
        (my $template) = grep {$_->stage() eq $stage and $_->destination() eq $template_name} @templates;
        unless ($template) {
            print "No such template \"$template_name\" in \"$configuration\"\n";
            return;
        }
        unless ($db->removeTemplates($template)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such template \"$template_name\" in \"$configuration\"\n";
        return;
    }
}

sub al {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n";
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return undef;
    }

    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        my %link;
        do {
            $link{stage} = prompt "stage (mount, sysinit, final)";
        } until ($link{stage} =~ m/^(?:mount|sysinit|final)$/);
        $link{source} = prompt "source";
        do {
            $link{destination} = prompt "destination";
        } until ($link{destination});
        $link{configuration} = $conf;
        perror $db->{error}."\n" unless ($db->addTemplates(Staple::Link->new(\%link)));
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
    }
}

sub at {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return undef;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n";
        return undef;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return undef;
    }
    my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
    if ($? != 0) {
        print "Can't create temporary file on /tmp/\n";
        return;
    }    
    chomp $tmpFile;
    unless (edit($tmpFile)) {
        unlink $tmpFile;
        return;
    }
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        my %template;
        $template{source} = $tmpFile;
        $template{uid} = prompt "uid", $UID;
        $template{gid} = prompt "gid", $GID + 0;
        $template{mode} = oct(prompt "mode", 644);
        do {
            $template{stage} = prompt "stage (mount, sysinit, final)";
        } until ($template{stage} =~ m/^(?:mount|sysinit|final)$/);
        do {
            $template{destination} = prompt "destination";
        } until ($template{destination});
        $template{configuration} = $conf;
        perror $db->{error}."\n" unless ($db->addTemplates(Staple::Template->new(\%template)));
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
    }
    unlink $tmpFile
}

sub ut {
    my $configuration = shift;
    my $stage = shift;
    my $template_name = shift;
    (my @templates) = localgettemplates($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($template_name) {
        print "Missing Template\n";
        return;
    }
    if (@templates and $templates[0]) {
        (my $template) = grep {$_->stage() eq $stage and $_->destination() eq $template_name} @templates;
        unless ($template) {
            print "No such template \"$template_name\" in \"$configuration\"\n";
            return;
        }

        if ($template->type() eq "link") {
            eval {
                local $SIG{INT} = sub {die "SIGINT"};
                my %newLink;
                do {
                    $newLink{stage} = prompt "stage (mount, sysinit, final)", $template->stage();
                } until ($newLink{stage} =~ m/^(?:mount|sysinit|final)$/);
                $newLink{source} = prompt "source", $template->source();
                $newLink{destination} = prompt "destination", $template->destination();
                $newLink{configuration} = $template->configuration();
                perror $db->{error}."\n" unless ($db->removeTemplates($template));
                perror $db->{error}."\n" unless ($db->addTemplates(Staple::Link->new(\%newLink)));
            };
            if ($@) {
                print "\n";
                print "$@" if index($@,"SIGINT") != 0;
            }
        } elsif ($template->type() eq "template") {

            my $data = $template->data();
            if ($template->error()) {
                print $template->error()."\n";
                return;
            }
            my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
            if ($? != 0) {
                print "Can't create temporary file on /tmp/\n";
                return;
            }
            chomp $tmpFile;
            unless (open(FILE, ">$tmpFile")) {
                print "Can't open temp file for writing $tmpFile: $!\n";
                unlink $tmpFile;
                return;
            }
            print FILE $data;
            close(FILE);
            unless (edit($tmpFile)) {
                unlink $tmpFile;
                return;
            }
            eval {
                local $SIG{INT} = sub {die "SIGINT"};
                my %newTemplate;
                $newTemplate{source} = $tmpFile;
                $newTemplate{uid} = prompt "uid", $template->uid();
                $newTemplate{gid} = prompt "gid", $template->gid();
                $newTemplate{mode} = oct(prompt "mode", sprintf("%04o", $template->mode()));
                do {
                    $newTemplate{stage} = prompt "stage (mount, sysinit, final)", $template->stage();
                } until ($newTemplate{stage} =~ m/^(?:mount|sysinit|final)$/);
                $newTemplate{destination} = prompt "destination", $template->destination();
                $newTemplate{configuration} = $template->configuration();
                perror $db->{error}."\n" unless ($db->removeTemplates($template));
                perror $db->{error}."\n" unless ($db->addTemplates(Staple::Template->new(\%newTemplate)));
            };
            if ($@) {
                print "\n";
                print "$@" if index($@,"SIGINT") != 0;
            }
            unlink $tmpFile
        } else {
            print "Bad template type: ".$template->type()."\n";
            return;
        }
    } else {
        print "No such template \"$template_name\" in \"$configuration\"\n";
        return;
    }
}

sub gts {
    my $configuration = shift;
    my $stage = shift;
    my $template_name = shift;
    (my @templates) = localgettemplates($configuration);
    unless ($stage) {
        print "Missing stage\n";
        return;
    }
    unless ($template_name) {
        print "Missing Template\n";
        return;
    }
    if (@templates and $templates[0]) {
        (my $template) = grep {$_->stage() eq $stage and $_->destination() eq $template_name} @templates;
        unless ($template) {
            print "No such template \"$template_name\" in \"$configuration\"\n";
            return;
        }
        my $data = $template->data();
        if ($template->error()) {
            perror $template->error()."\n";
            return;
        }
        if ($data !~ m/\n$/) {
            $data .= "\n(template doesn't end with new line)\n";
        }
        print $data;
    } else {
        print "No such template \"$template_name\" in \"$configuration\"\n";
        return;
    }
}

# gt is greate than, for my quick search: sub gt {
sub gtm {
    (my @templates) = localgettemplates(@_);
    if (@templates and $templates[0]) {
        foreach my $stage ("mount", "sysinit", "final") {
            next unless grep {$_->stage() eq $stage} @templates;
            print "  $stage:\n";
            print join "", map {"     ".$_->description()} grep {$_->stage() eq $stage} @templates;
        }
    }
}

sub rm {
    my $configuration = shift;
    my $mount = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    unless ($mount) {
        print "Missing mount\n";
        return;
    }
    if ($mount !~ m,^([+-])(.*)$,) {
        print "The mount should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $mount = $2;
    unless ($mount) {
        print "Missing mount\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n";
        return;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return;
    }
    unless ($db->removeMounts(Staple::Mount->new({destination => $mount, active => $active, configuration => $conf}))) {
        perror $db->{error}."\n";
        return;
    }
}

sub am {
    my $configuration = shift;
    my $mount = shift;
    my $location = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    unless ($mount) {
        print "Missing mount\n";
        return;
    }
    if ($mount !~ m,^([+-])(.*)$,) {
        print "The mount should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $mount = $2;
    unless ($mount) {
        print "Missing mount\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    unless ($conf) {
        print "unknown configuration \"$configuration\"\n";
        return;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
        return;
    }
    unless ($db->addMount($conf, Staple::Mount->new({destination => $mount, active => $active}), $location)) {
        perror $db->{error}."\n";
        return;
    }
}

sub gm {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configurations\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        ($conf) = $db->getFullConfigurations([$conf], $distribution);
        if ($conf) {
            my @mounts = $db->getMounts($conf);
            if (@mounts and not defined $mounts[0]) {
                perror $db->{error}."\n";
                return;
            } else {
                print join "\n", map {"  ".$_->description()} @mounts;
                print "\n" if (@mounts);
            }
        } else {
            print "No such configuration \"$configuration\" under the \"$distribution\" distribution\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub rgc {
    my $group_name = shift;
    my $configuration = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configuration should be preceded with + or -\n";
        return;
    }
    (my $group) = $db->getGroupsByName($group_name);
    unless ($group) {
        print "Unknown group \"$group_name\"\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->removeGroupConfigurations($group, $conf)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub rdc {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configuration should be preceded with + or -\n";
        return;
    }
    my $group = $db->getDistributionGroup($distribution);
    unless ($group) {
        print "Unknown distribution \"$distribution\"\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->removeGroupConfigurations($group, $conf)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub rhc {
    my $host = shift;
    my $configuration = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configuration should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    my $group = $db->getHostGroup($host);
    unless ($group) {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            $configuration = ($active ? "+" : "-").$configuration;
            rhc($_, $configuration) foreach @hosts;
        } else {
            print "unknown host \"$host\"\n";
        }
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->removeGroupConfigurations($group, $conf)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub agc {
    my $group_name = shift;
    my $configuration = shift;
    my $location = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configurations should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    (my $group) = $db->getGroupsByName($group_name);
    unless ($group) {
        print "unknown group \"$group_name\"\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->addGroupConfiguration($group, $conf, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub rcc {
    my $conf_name = shift;
    my $configuration = shift;
    unless ($conf_name) {
        print "Missing configuration to remove from\n";
        return;
    }
    unless ($configuration) {
        print "Missing configuration to remove\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configuration should be preceded with + or -\n";
        return;
    }
    (my $conf) = $db->getFullConfigurations([$conf_name], $distribution);
    unless ($conf) {
        print "Unknown configuration \"$conf_name\"\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration to remove\n";
        return;
    }
    (my $conf2rm) = $db->getConfigurationsByName($configuration);
    if ($conf2rm) {
        $conf2rm->active($active);
        unless ($db->removeConfigurationConfigurations($conf, $conf2rm)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub gcc {
    my $configuration_name = shift;
    unless ($configuration_name) {
        print "Missing configuration\n";
        return;
    }
    my @configurations_names = splitData($configuration_name);
    (my $conf) = $db->getConfigurationsByName($configuration_name);
    unless ($conf) {
        print "No such configuration \"$configuration_name\"\n";
        return;
    }
    @configurations_names = $configuration_name if $singleCommand;
    my @confs = $db->getFullConfigurations([$db->getConfigurationsByName(@configurations_names)], $distribution);
    my $prefix = $singleCommand ? "" : "  ";
    foreach my $conf (@confs) {
        print $conf->name().":\n" unless $singleCommand;
        my @configurations = $db->getConfigurationConfigurations($conf);
        if (@configurations and not defined $configurations[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            if (@configurations) {
                print "$prefix";
                print join "\n$prefix", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
                print "\n";
            }
            print "\n" unless $singleCommand;
        }
    }
}

sub acc {
    my $configuration_name = shift;
    my $configuration = shift;
    my $location = shift;
    unless ($configuration_name) {
        print "Missing configuration to add to\n";
        return;
    }
    unless ($configuration) {
        print "Missing configuration to add\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configurations to add should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration to add\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration_name);
    unless ($conf) {
        print "unknown configuration \"$configuration_name\"\n";
        return;
    }
    ($conf) = $db->getFullConfigurations([$conf], $distribution);
    unless ($conf) {
        print "No such configuration \"$configuration_name\" under the \"$distribution\" distribution\n";
        return;
    }
    (my $conf2) = $db->getConfigurationsByName($configuration);
    if ($conf2) {
        $conf2->active($active);
        unless ($db->addConfigurationConfiguration($conf, $conf2, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub adc {
    my $configuration = shift;
    my $location = shift;
    unless ($configuration) {
        print "Missing configurations\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configurations should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    my $group = $db->getDistributionGroup($distribution);
    unless ($group) {
        print "unknown distribution \"$distribution\"\n";
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->addGroupConfiguration($group, $conf, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub ahc {
    my $host = shift;
    my $configuration = shift;
    my $location = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($configuration) {
        print "Missing configurations\n";
        return;
    }
    if ($configuration !~ m,^([+-])(.*)$,) {
        print "The configurations should be preceded with + or -\n";
        return;
    }
    my $active = $1 eq '+' ? 1 : 0;
    $configuration = $2;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    my $group = $db->getHostGroup($host);
    unless ($group) {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            $configuration = ($active ? "+" : "-").$configuration;
            ahc($_, $configuration, $location) foreach @hosts;
        } else {
            print "unknown host \"$host\"\n";
        }
        return;
    }
    (my $conf) = $db->getConfigurationsByName($configuration);
    if ($conf) {
        $conf->active($active);
        unless ($db->addGroupConfiguration($group, $conf, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such configuration \"$configuration\"\n";
        return;
    }
}

sub gdc {
    my $dist = shift;
    $dist = $distribution unless $dist;
    if (my $group = $db->getDistributionGroup($dist)) {
        my @configurations = $db->getGroupsConfigurations($group);
        if (@configurations and not defined $configurations[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            print join "\n", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
            print "\n";
        }
    } else {
        print "No such distribution \"$dist\"\n";
        return;
    }
}

sub ghc {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    if (my $group = $db->getHostGroup($host)) {
        my @configurations = $db->getGroupsConfigurations($group);
        if (@configurations and not defined $configurations[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            print join "\n", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
            print "\n";
        }
    } else {
        print "No such host \"$host\"\n";
        return;
    }
}

sub gdn {
    my $dist = shift;
    $dist = $distribution unless ($dist);
    if (my $group = $db->getDistributionGroup($dist)) {
        if (my $note = $db->getNote($group)) {
            print "$note\n";
        } else {
            print "No note for distribution \"$dist\"\n";
        }
    } else {
        print "No such distribution \"$dist\"\n";
        return;
    }
}

sub sdn {
    my $dist = shift;
    my $note = join " ", @_;
    unless ($dist) {
        print "Missing distribution\n";
    }
    if (my $group = $db->getDistributionGroup($dist)) {
        perror "Error: $db->{error}\n" unless ($db->setNote($group, $note));
    } else {
        print "No such distribution \"$dist\"\n";
        return;
    }
}

sub ghn {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    if (my $group = $db->getHostGroup($host)) {
        if (my $note = $db->getNote($group)) {
            print "$note\n";
        } else {
            print "No note for host \"$host\"\n";
        }
    } else {
        print "No such host \"$host\"\n";
        return;
    }
}

sub shn {
    my $host = shift;
    my $note = join " ", @_;
    unless ($host) {
        print "Missing host\n";
    }
    if (my $group = $db->getHostGroup($host)) {
        perror "Error: $db->{error}\n" unless ($db->setNote($group, $note));
    } else {
        print "No such host \"$host\"\n";
        return;
    }
}

sub sgn {
    my $group_name = shift;
    my $note = join " ", @_;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    if ((my $group) = $db->getGroupsByName($group_name)) {
        unless ($db->setNote($group, $note)) {
            perror "Error: $db->{error}\n";
            return;
        }
    } else {
        print "No such group \"$group_name\"\n";
        return;
    }
}

sub ggn {
    my $group_name = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    if ((my $group) = $db->getGroupsByName($group_name)) {
        if (my $note = $db->getNote($group)) {
            print "$note\n";
        } else {
            print "No note for group \"$group_name\"\n";
        }
    } else {
        print "No such group \"$group_name\"\n";
        return;
    }
}

sub scn {
    my $conf = shift;
    my $note = join " ", @_;
    unless ($conf) {
        print "Missing configuration\n";
        return;
    }
    if ((my $group) = $db->getFullConfigurations([$conf], $distribution)) {
        unless ($db->setNote($group, $note)) {
            perror "Error: $db->{error}\n";
            return;
        }
    } else {
        print "No such configuration \"$conf\"\n";
        return;
    }
}

sub gcn {
    my $conf = shift;
    unless ($conf) {
        print "Missing configuration\n";
        return;
    }
    if ((my $group) = $db->getFullConfigurations([$conf], $distribution)) {
        if (my $note = $db->getNote($group)) {
            print "$note\n";
        } else {
            print "No note for configuration \"$conf\"\n";
        }
    } else {
        print "No such configuration \"$conf\"\n";
        return;
    }
}

sub ggc {
    my $group_name = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    my @groups_names = splitData($group_name);
    (my $groupg) = $db->getGroupsByName($group_name);
    unless ($groupg) {
        print "No such group \"$group_name\"\n";
        return;
    }
    @groups_names = $group_name if ($singleCommand);
    my @groups = $db->getGroupsByName(@groups_names);
    my $prefix = $singleCommand ? "" : "  ";
    foreach my $group (@groups) {
        print $group->name().":\n" unless $singleCommand;
        my @configurations = $db->getGroupsConfigurations($group);
        if (@configurations and not defined $configurations[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            if (@configurations) {
                print "$prefix";
                print join "\n$prefix", map {($_->active() ?  "+" : "-").$_->name()} @configurations;
                print "\n";
            }
            print "\n" unless $singleCommand;
        }
    }
}

sub agg {
    my $group1 = shift;
    my $group2 = shift;
    my $location = shift;
    unless ($group1) {
        print "Missing group1\n";
        return;
    }
    unless ($group2) {
        print "Missing group2\n";
        return;
    }
    (my $groupGroup) = $db->getGroupsByName($group1);
    if ($groupGroup) {
        unless ($db->addGroupGroup($groupGroup, $group2, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such group \"$group1\"\n";
        return;
    }
}

sub rgg {
    my $group1 = shift;
    my $group2 = shift;
    unless ($group1) {
        print "Missing group1\n";
        return;
    }
    unless ($group2) {
        print "Missing group2\n";
        return;
    }
    (my $groupGroup) = $db->getGroupsByName($group1);
    if ($groupGroup) {
        unless ($db->removeGroupGroups($groupGroup, $group2)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such group \"$group1\"\n";
        return;
    }
}

sub adg {
    my $group = shift;
    my $location = shift;
    unless ($group) {
        print "Missing group\n";
        return;
    }
    if (my $distributionGroup = $db->getDistributionGroup($distribution)) {
        unless ($db->addGroupGroup($distributionGroup, $group, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such distribution \"$distribution\"\n";
        return;
    }
}

sub rdg {
    my $group = shift;
    unless ($group) {
        print "Missing group\n";
        return;
    }
    if (my $distributionGroup = $db->getDistributionGroup($distribution)) {
        unless ($db->removeGroupGroups($distributionGroup, $group)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        print "No such host \"$distribution\"\n";
        return;
    }
}

sub ahg {
    my $host = shift;
    my $group = shift;
    my $location = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($group) {
        print "Missing group\n";
        return;
    }
    if (my $hostGroup = $db->getHostGroup($host)) {
        unless ($db->addGroupGroup($hostGroup, $group, $location)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            ahg($_, $group, $location) foreach @hosts;
        } else {
            print "unknown host \"$host\"\n";
        }
        return;
    }
}

sub rhg {
    my $host = shift;
    my $group = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($group) {
        print "Missing group\n";
        return;
    }
    if (my $hostGroup = $db->getHostGroup($host)) {
        unless (grep {$_->name() eq "$group"} $db->getGroupGroups($hostGroup)) {
            print "\"$host\" doesn't have the group \"$group\"\n";
            return;
        }
        unless ($db->removeGroupGroups($hostGroup, $group)) {
            perror $db->{error}."\n";
            return;
        }
    } else {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            rhg($_, $group) foreach @hosts;
        } else {
            print "unknown host \"$host\"\n";
        }
        return;
    }
}

sub gdg {
    my $dist = shift;
    $dist = $distribution unless $dist;
    if (my $group = $db->getDistributionGroup($dist)) {
        my @groups = $db->getGroupGroups($group);
        if (@groups and not defined $groups[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            print join "\n", map {$_->name()} @groups;
            print "\n";
        }
    } else {
        print "No such distribution \"$dist\"\n";
        return;
    }
}

sub ggg {
    my $group_name = shift;
    unless ($group_name) {
        print "Missing group\n";
        return;
    }
    (my $group) = $db->getGroupsByName($group_name);
    if ($group) {
        my @groups = $db->getGroupGroups($group);
        if (@groups and not defined $groups[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            print join "\n", map {$_->name()} @groups;
            print "\n";
        }
    } else {
        print "No such group \"$group_name\"\n";
        return;
    }
}

sub ghg {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    if (my $group = $db->getHostGroup($host)) {
        my @groups = $db->getGroupGroups($group);
        if (@groups and not defined $groups[0]) {
            perror $db->{error}."\n";
            return;
        } else {
            print join "\n", map {$_->name()} @groups;
            print "\n";
        }
    } else {
        print "No such host \"$host\"\n";
        return;
    }
}

# returns the tokens hash (with a single token), or undef
sub createToken {
    my $token;
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        print "type ([static], dynamic, regexp): ";
        my $type = <>;
        chomp($type);
        $type = lc($type);
        $type = "static" unless $type;
        if ($type !~ m/^static|dynamic|regexp$/) {
            print "Unknown type\n";
            return;
        }
        print "key: ";
        my $key = <>;
        my $value;
        if ($key =~ m/=/) {
            ($key, $value) = $key =~ m/^([^=]+)=(.*)$/s;
            while ($value !~ m/;\n$/) {
                $value .= <>;
            }
        } else {
            print "value (end with ;): ";
            $value = "";
            do {
                $value .= <>;
            } until ($value =~ m/;\n$/);
        }
        chomp($key);
        $value =~ s/;\n$//;
        $token = {"$key" => {key => $key, value => $value, raw => $value, type => $type}};
    };
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
    } else {
        return $token;
    }
}

sub addToken {
    my $node = shift;
    my $token = createToken();
    unless ($token) {
        print "no token added\n";
    } else {
        unless ($db->addTokens($token, $node)) {
            perror $db->{error}."\n";
        }
    }
}

sub act {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    if ((my $conf) = $db->getConfigurationsByName($configuration)) {
        ($conf) = $db->getFullConfigurations([$conf], $distribution);
        addToken($conf);
    } else {
        print "Configuration \"$configuration\" does no exist\n";
    }
}

sub updateToken {
    my $node = shift;
    my $token = shift;
    my $oldtoken = $db->getTokens($node);
    unless ($oldtoken) {
        perror $db->{error}."\n";
        return;
    }
    unless (exists $oldtoken->{$token}) {
        perror "\"$node->{name}\" don't have a \"$token\" token.\n";
        return;
    }
    $oldtoken = $oldtoken->{$token};
    my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
    if ($? != 0) {
        perror "Can't create temporary file on /tmp/\n";
        return;
    }
    chomp $tmpFile;
    unless (open(FILE, ">$tmpFile")) {
        print "Can't open temporary file for writing $tmpFile: $!\n";
        unlink $tmpFile;
        return;
    }
    print FILE $oldtoken->{raw};
    close(FILE);
    unless (edit($tmpFile)) {
        unlink $tmpFile;
        return;
    }
    my $newtoken = {};
    unless (open(FILE, "<$tmpFile")) {
        perror "Can't open saved file for reading: $!\n";
        unlink $tmpFile;
        return;
    }
    {
        local $/;
        $newtoken->{raw} = <FILE>;
        close(FILE);
    }
    eval {
        local $SIG{INT} = sub {die "SIGINT"};
        $newtoken->{key} = prompt "key", $token;
        do {
            $newtoken->{type} = prompt "type (static, dynamic, regexp)", $oldtoken->{type};
        } until ($newtoken->{type} =~ m/^(?:static|dynamic|regexp)$/);
    };
    unlink $tmpFile;
    if ($@) {
        print "\n";
        print "$@" if index($@,"SIGINT") != 0;
        return;
    }
    if ($newtoken->{key} ne $token) {
        unless ($db->removeTokens([$token], $node)) {
            perror "Can't remove previous token: ".$db->{error}."\n";
        }
    }
    unless ($db->addTokens({$newtoken->{key} => $newtoken}, $node)) {
        perror $db->{error}."\n";
    }
}


sub updateAllTokens {
    use Data::Dumper;
    my $node = shift;
    my $tokens = $db->getTokens($node);
    unless ($tokens) {
        perror $db->{error}."\n";
        return;
    }
    my $tmpFile = `mktemp /tmp/staplectl.XXXXXXXX 2>/dev/null`;
    if ($? != 0) {
        perror "Can't create temporary file on /tmp/\n";
        return;
    }
    chomp $tmpFile;
    unless (writeTokensXMLFile($tmpFile, $tokens)) {
        print "Can't write tokens file\n";
        unlink $tmpFile;
        return;
    }
    unless (edit($tmpFile)) {
        unlink $tmpFile;
        return;
    }
    my @tokens = readTokensXMLFile($tmpFile);
    unlink $tmpFile;
    if (@tokens and not defined $tokens[0]) {
        perror "Error parsing tokens file\n";
        return;
    }
    my %tokens = @tokens;
    unless ($db->setTokens(\%tokens, $node)) {
        perror $db->{error}."\n";
    }
}

sub ugt {
    my $groupName = shift;
    my $token = shift;
    unless ($groupName) {
        print "Missing group\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return
    }
    (my $group) = $db->getGroupsByName($groupName);
    unless ($group) {
        print "Group \"$groupName\" does not exist\n";
        return;
    }
    updateToken($group, $token);
}

sub uct {
    my $configuration = shift;
    my $token = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return;
    }
    (my $conf) = $db->getFullConfigurations([$configuration], $distribution);
    unless ($conf) {
        print "Configuration \"$configuration\" does no exist\n";
        return;
    }
    updateToken($conf, $token);
}

sub uact {
    my $configuration = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    (my $conf) = $db->getFullConfigurations([$configuration], $distribution);
    unless ($conf) {
        print "Configuration \"$configuration\" does no exist\n";
        return;
    }
    updateAllTokens($conf);
}

sub uagt {
    my $groupName = shift;
    unless ($groupName) {
        print "Missing group\n";
        return;
    }
    (my $group) = $db->getGroupsByName($groupName);
    unless ($group) {
        print "Group \"$groupName\" does not exist\n";
        return;
    }
    updateAllTokens($group);
}

sub uaht {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    my $group = $db->getHostGroup($host);
    unless ($group) {
        perror $db->{error}."\n";
        return;
    }
    updateAllTokens($group);
}

sub uadt {
    my $dist = $distribution;
    $dist = shift if $_[0];
    my $group = $db->getDistributionGroup($dist);
    unless ($group) {
        perror $db->{error}."\n";
        return;
    }
    updateAllTokens($group);
}

sub udt {
    my $dist = $distribution;
    $dist = shift if $_[1];
    my $token = shift;
    unless ($token) {
        print "Missing token\n";
        return;
    }
    my $group = $db->getDistributionGroup($dist);
    unless ($group) {
        perror $db->{error}."\n";
        return;
    }
    updateToken($group, $token);
}


sub uht {
    my $host = shift;
    my $token = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return;
    }
    my $group = $db->getHostGroup($host);
    unless ($group) {
        perror $db->{error}."\n";
        return;
    }
    updateToken($group, $token);
}

sub rct {
    my $configuration = shift;
    my $token = shift;
    unless ($configuration) {
        print "Missing configuration\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return;
    }
    if ((my $conf) = $db->getConfigurationsByName($configuration)) {
        ($conf) = $db->getFullConfigurations([$conf], $distribution);
        unless ($db->removeTokens([$token], $conf)) {
            perror $db->{error}."\n";
        }
    } else {
        print "Configuration \"$configuration\" does not exist\n";
    }
}

sub agt {
    my $groupName = shift;
    unless ($groupName) {
        print "Missing group\n";
        return;
    }
    if ((my $group) = $db->getGroupsByName($groupName)) {
        addToken($group);
    } else {
        print "Group \"$groupName\" does not exist\n";
    }
}

sub rgt {
    my $groupName = shift;
    my $token = shift;
    unless ($groupName) {
        print "Missing group\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return;
    }
    if ((my $group) = $db->getGroupsByName($groupName)) {
        unless ($db->removeTokens([$token], $group)) {
            perror $db->{error}."\n";
        }
    } else {
        print "Group \"$groupName\" does not exist\n";
    }
}

sub aht {
    my $host = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    my @hosts = ($host);
    if (isRange($host)) {
        @hosts = parseRange($host);
    }
    my $token = createToken();
    unless ($token) {
        print "no token added\n";
    } else {
        foreach my $rhost (@hosts) { 
            if (my $group = $db->getHostGroup($rhost)) {
                unless ($db->addTokens($token, $group)) {
                    perror $db->{error}."\n";
                }
            } else {
                print "Host \"$rhost\" doesn't exist\n";
            }
        }
    }
}

sub rht {
    my $host = shift;
    my $token = shift;
    unless ($host) {
        print "Missing host\n";
        return;
    }
    unless ($token) {
        print "Missing token\n";
        return;
    }
    my @hosts = ($host);
    @hosts = parseRange($host) if isRange($host);
    foreach my $rhost (@hosts) {
        if (my $group = $db->getHostGroup($rhost)) {
            unless ($db->removeTokens([$token], $group)) {
                perror $db->{error}."\n";
            }
        } else {
            print "Host \"$rhost\" does not exist\n";
        }
    }
}

sub adt {
    my $dist = $distribution;
    $dist = $_[0] if $_[0];
    if (my $group = $db->getDistributionGroup($dist)) {
        addToken($group);
    } else {
        perror $db->{error}."\n";
    }
}

sub rdt {
    my $dist = $distribution;
    $dist = shift if $_[1];
    my $token = shift;
    unless ($token) {
        print "Missing token\n";
        return;
    }
    if (my $group = $db->getDistributionGroup($distribution)) {
        unless ($db->removeTokens([$token], $group)) {
            perror $db->{error}."\n";
        }
    } else {
        perror $db->{error}."\n";
    }
}

sub printgctokens {
    if (my $tokens = $db->getTokens($_[0])) {
        if ($singleCommand) {
            print tokensToXML($tokens);
        } else {
            my %tokens = %$tokens;
            foreach my $type ("static", "dynamic", "regexp") {
                my @tokens = grep {$_->{type} eq $type} values %tokens;
                if (@tokens) {
                    print "- $type:\n";
                    print join "\n", map "     $_->{key}=$_->{raw}", sort {$a->{key} cmp $b->{key}} @tokens;
                    print "\n";
                }
            }
        }
    } else {
        perror $db->{error}."\n";
    }
}

sub gct {
    if ($_[0]) {
        (my $configuration) = $db->getFullConfigurations([$_[0]], $distribution);
        if ($configuration) {
            printgctokens($configuration);
        } else {
            print "Unknown configuration \"$_[0]\"\n";
        }
    } else {
        print "Missing configuration\n";
    }
}

sub ggt {
    if ($_[0]) {
        (my $group) = $db->getGroupsByName($_[0]);
        if ($group) {
            printgctokens($group);
        } else {
            print "Unknown group \"$_[0]\"\n";
        }
    } else {
        print "Missing group\n";
    }
}

sub gdt {
    my $dist = $distribution;
    if ($_[0]) {
        $dist = shift;
    }
    if ($dist) {
        my $group = $db->getDistributionGroup($dist);
        if ($group) {
            printgctokens($group);
        } else {
            print "Unknown distribution \"$distribution\"\n";
        }
    } else {
        print "distribution not set\n";
    }
}

sub ght {
    if ($_[0]) {
        my $host = $db->getHostGroup($_[0]);
        if ($host) {
            printgctokens($host);
        } else {
            print "Unknown host \"$_[0]\"\n";
        }
    } else {
        print "Missing host\n";
    }
}

sub gac {
    unless ($distribution) {
        print "distribution not set\n";
        return;
    }
    my @configurations = $db->getAllConfigurations($distribution);
    if (@configurations and not defined $configurations[0]) {
        perror $db->{error}."\n";
    } else {
        if ($_[0]) {
            my $regexp = qr/$_[0]/;
            @configurations = grep {$_ =~ m/$regexp/} @configurations;
        }
        print join "\n", @configurations;
        print "\n";
    }
}

sub ac {
    unless ($distribution) {
        print "distribution not set\n";
        return;
    }
    perror $db->{error}."\n" unless $db->addConfiguration($distribution, $_[0]);
}

sub rc {
    unless ($distribution) {
        print "distribution not set\n";
        return;
    }
    perror $db->{error}."\n" unless $db->removeConfiguration($distribution, $_[0]);
}

sub sd {
    if ($_[0]) {
        my @distributions = $db->getAllDistributions();
        if (@distributions and not defined $distributions[0]) {
            perror "Can't get distribution list: ".$db->{error}."\n";
        } else {
            my %distributions = ();
            @distributions{@distributions} = @distributions;
            if ($distributions{$_[0]}) {
                $distribution = $_[0];
            } else {
                print "No such distribution \"$_[0]\"\n";
            }
        }
    } else {
        print "Missing distribution\n";
    }
    print "Current distribution: ".($distribution ? "$distribution (".$db->getDistributionVersion($distribution).")" : "UNKNOWN")."\n";
}

sub ndb {
    unless (@_) {
        perror "Must specify a database to create\n";
        return;
    }
    sdb2(createDBinit(@_));
}

# for search: sub sdb {
sub setdb {
    sdb2(createDB(@_));
}

# for ndb and sdb
sub sdb2 {
    my $newDB = shift;
    unless (ref $newDB) {
        perror "$newDB\n";
    } elsif ($newDB->{error}) {
        perror "$newDB->{error}\n";
    } else {
        $db = $newDB;
        if ($db) {
            my @distributions = $db->getAllDistributions();
            $distribution = getDistribution() unless $distribution;
            unless (grep {$_ eq $distribution} @distributions) {
                print "$distribution doesn't exist in this database\n" if $distribution;
                $distribution = undef;
            }
        }
    }
    print "Current database: ".$db->info()."\n";
}

sub getdb {
    print $db->info()."\n";
}

sub gah {
    my @hosts = $db->getAllHosts();
    if (@hosts and not defined $hosts[0]) {
        perror $db->{error}."\n";
    } else {
        if ($_[0]) {
            my $regexp = qr/$_[0]/;
            @hosts = grep {$_ =~ m/$regexp/} @hosts;
        }
        print join "\n", @hosts;
        print "\n";
    }
}

sub ah {
    my $host = shift;
    fillDnsHostList() unless @dnsHostList;
    if (@dnsHostList and not grep {$_ eq $host} @dnsHostList) {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            ah($_) foreach @hosts;
            return;
        } else {
            print "Warning: I don't think that \"$host\" is in the DNS\n";
        }
    }
    perror $db->{error}."\n" unless $db->addHost($host);
}

sub rh {
    my $host = shift;
    unless ($db->getHostGroup($host)) {
        if (isRange($host)) {
            my @hosts = parseRange($host);
            rh($_) foreach @hosts;
            return;
        }
    }
    perror $db->{error}."\n" unless $db->removeHost($host);
}

sub gag {
    my @groups = $db->getAllGroups();
    if (@groups and not defined $groups[0]) {
        perror $db->{error}."\n";
    } else {
        if ($_[0]) {
            my $regexp = qr/$_[0]/;
            @groups = grep {$_ =~ m/$regexp/} @groups;
        }
        #print join "\n", @groups;
        #print "\n";
        printTree(@groups);
    }
}

sub ag {
    perror $db->{error}."\n" unless $db->addGroup($_[0]);
}

sub rg {
    perror $db->{error}."\n" unless $db->removeGroup($_[0]);
}

sub gad {
    my @distributions = $db->getAllDistributions();
    if (@distributions and not defined $distributions[0]) {
        perror $db->{error}."\n";
    } else {
        my @versions = map{$db->getDistributionVersion($_)} @distributions;
        @distributions = map {$distribution eq $_ ? "(*) $_" : "    $_"} @distributions if $distribution;
        my $len = 0;
        map {$len = length($_) if $len < length($_)} @distributions;
        @distributions = map {sprintf("\%-${len}s  \%s", $_, "(".(shift @versions).")")} @distributions;

        print join "\n", @distributions;
        print "\n";
    }
}

sub ad {
    my $dist = shift;
    my $version = shift;
    unless ($db->addDistribution($dist, $version)) {
        perror $db->{error}."\n"
    } 
}

sub rd {
    perror $db->{error}."\n" unless $db->removeDistribution($_[0]);
}

sub syncctl {
    my $db1;
    my $db2;
    my @db1params = ();
    my @db2params = ();
    print "sync from <db> [<params...>]: ";
    my $line = <>;
    chomp($line);
    return unless $line;
    $line = "setdb $line";
    (my $command, @db1params) = parseline($line);
    $db1 = createDB(@db1params);
    unless (ref $db1) {
        perror "$db1\n";
        return;
    } elsif ($db1->{error}) {
        perror "$db1->{error}\n";
        return;
    }
    
    print "sync to <db> [<params...>]: ";
    $line = <>;
    return unless $line;
    chomp($line);
    $line = "setdb $line";
    ($command, @db2params) = parseline($line);
    $db2 = createDB(@db2params);
    unless (ref $db2) {
        perror "$db2\n";
        return;
    } elsif ($db2->{error}) {
        perror "$db2->{error}\n";
        return;
    }
    perror "sync failed: ".$db1->{error}."\n" unless $db1->syncTo($db2, 1);
}

sub parseline {
    my $line = shift;
    $line =~ s/\s+/ /g;
    $line =~ s/^\s*//;
    $line =~ s/\s*$//;
    (my $command, my @params) = split / /, $line;
    $command = lc($command);
    $command = " " unless $command;
    while (not $commandMap{$command} or not $commands{$commandMap{$command}}) {
        if (@params) {
            $command .= lc(shift @params);
        } else {
            $command = "badcommandorfilename";
        }
    }
    my @fixedParams;
    while (my $param = shift @params) {
        if ($param eq '!$') {
            my $temp = (split / /, $lastCommand)[-1];
            $param = $temp if $temp;
        }
        if ($param =~ m/\\$/) {
            my $temp = shift @params;
            if ($temp) {
                $param =~ s/\\$//;
                $param .= " $temp";
            }
        }
        push @fixedParams, $param;
    }
    $lastCommand = join " ", ($command, @fixedParams) if $command ne "badcommandorfilename";
    return $command, @fixedParams;
}

###
#   readline stuff
###

my @currentCompletionList = ();
my $currentCommand = "";

# complete database
sub database_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        my %dbs = listDB();
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = grep {index($_, $text) == 0} grep {$_ ne "error"} keys %dbs;
    }
    return $currentCompletionList[$count];
}

# completes last group configurations, assumes last word was a group
sub group_configurations_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $group_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $group_name;
        (my $group) = $db->getGroupsByName($group_name);
        return () unless $group;
        my @confs = $db->getGroupsConfigurations($group);
        return () if (@confs and not defined $confs[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {($_->active() ?  "+" : "-").$_->name()} @confs;
    }
    return $currentCompletionList[$count];
}

# completes current distribution configurations
sub distribution_configurations_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $group = $db->getDistributionGroup($distribution);
        return () unless $group;
        my @confs = $db->getGroupsConfigurations($group);
        return () if (@confs and not defined $confs[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {($_->active() ?  "+" : "-").$_->name()} @confs;
    }
    return $currentCompletionList[$count];
}

# completes host configuration, assumes last word was host
sub host_configurations_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $host = (split(/\s+/, $currentCommand))[-1];
        return () unless $host;
        my @groups;
        if (isRange($host)) {
            foreach my $h (parseRange($host)) {
                $h = $db->getHostGroup($h);
                push @groups, $h if $h
            }
        } else {
            my $h = $db->getHostGroup($host);
            @groups = $h if $h;
        }
        return () unless @groups;
        my @confs = $db->getGroupsConfigurations(@groups);
        return () if (@confs and not defined $confs[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {($_->active() ?  "+" : "-").$_->name()} @confs;
    }
    return $currentCompletionList[$count];
}

# completes last group configurations, assumes last word was a configuration
sub configuration_configurations_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $conf_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $conf_name;
        (my $conf) = $db->getFullConfigurations([$conf_name], $distribution);
        return () unless $conf;
        my @confs = $db->getConfigurationConfigurations($conf);
        return () if (@confs and not defined $confs[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {($_->active() ?  "+" : "-").$_->name()} @confs;
    }
    return $currentCompletionList[$count];
}

# completes singed configuration
sub sign_configuration_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        @currentCompletionList = ();
        if (length($text) < 1) {
            $attribs->{completion_append_character} = "";
            @currentCompletionList = grep {index($_, $text) == 0} qw(+ -);
        } else {
            return () unless $text =~ m,^([+-])(.*),;
            my $sign = $1;
            my $conf = $2;
            configuration_completion($conf, 0);
            @currentCompletionList = map {"$sign$_"} @currentCompletionList;
        }
    }
    return $currentCompletionList[$count];
}

# completes groups for host, assumes last word was a host
sub host_groups_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $host = (split(/\s+/, $currentCommand))[-1];
        return () unless $host;
        my @gs;
        if (isRange($host)) {
            foreach my $h (parseRange($host)) {
                $h = $db->getHostGroup($h);
                push @gs, $h if $h
            }
        } else {
            my $h = $db->getHostGroup($host);
            @gs = $h if $h;
        }
        return () unless @gs;
        my @groups = $db->getGroupGroups(@gs);
        return () if (@groups and not defined $groups[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {$_->name()} @groups;
    }
    return $currentCompletionList[$count];
}

# copmletes tokens for last host, assumes last word is a host
sub host_tokens_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $host = (split(/\s+/, $currentCommand))[-1];
        return () unless $host;
        my @groups;
        if (isRange($host)) {
            foreach my $h (parseRange($host)) {
                $h = $db->getHostGroup($h);
                push @groups, $h if $h
            }
        } else {
            my $h = $db->getHostGroup($host);
            @groups = $h if $h;
        }
        return () unless @groups;
        my $tokens = $db->getTokens(@groups);
        my @tokens = keys %$tokens;
        @currentCompletionList = grep {index($_, $text) == 0} @tokens;
    }
    return $currentCompletionList[$count];
}

# completes tokens for last group, assumes last word is a group
sub group_tokens_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $group_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $group_name;
        (my $group) = $db->getGroupsByName($group_name);
        return () unless $group;
        my $tokens = $db->getTokens($group);
        my @tokens = keys %$tokens;
        @currentCompletionList = grep {index($_, $text) == 0} @tokens;
    }
    return $currentCompletionList[$count];
}

# completes distributions and tokens for current distribution
sub distribution_and_tokens_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        distribution_completion($text, 0);
        my @temp = @currentCompletionList;
        my $temp = $currentCommand;
        $currentCommand = $distribution;
        distribution_tokens_completion($text, 0);
        $currentCommand = $temp;
        push @currentCompletionList, @temp;
    }
    return $currentCompletionList[$count];
}

# copmletes tokens for last distribution, assumes last word is a distribution
sub distribution_tokens_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $dist_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $dist_name;
        my $dist = $db->getDistributionGroup($dist_name);
        return () unless $dist;
        my $tokens = $db->getTokens($dist);
        my @tokens = keys %$tokens;
        @currentCompletionList = grep {index($_, $text) == 0} @tokens;
    }
    return $currentCompletionList[$count];
}

# copmletes tokens for last configuration, assumes last word is a configuration
sub configuration_tokens_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $conf_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $conf_name;
        (my $configuration) = $db->getFullConfigurations([$conf_name], $distribution);
        return () unless $configuration;
        my $tokens = $db->getTokens($configuration);
        my @tokens = keys %$tokens;
        @currentCompletionList = grep {index($_, $text) == 0} @tokens;
    }
    return $currentCompletionList[$count];
}

# copmletes groups for last group, assumes last word is a group
sub group_groups_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $group = (split(/\s+/, $currentCommand))[-1];
        return () unless $group;
        ($group) = $db->getGroupsByName($group);
        return () unless $group;
        my @groups = $db->getGroupGroups($group);
        return () if (@groups and not defined $groups[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {$_->name()} @groups;
    }
    return $currentCompletionList[$count];
}

# completes groups for distributions
sub distribution_groups_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $group = $db->getDistributionGroup($distribution);
        return () unless $group;
        my @groups = $db->getGroupGroups($group);
        return () if (@groups and not defined $groups[0]);
        @currentCompletionList = grep {index($_, $text) == 0} map {$_->name()} @groups;        
    }
    return $currentCompletionList[$count];
}

# completes auto name, assume last word is configuration
sub auto_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $configuration = (split(/\s+/, $currentCommand))[-1];
        $echooff = 1;
        (my @autos) = localgetautos($configuration);
        $echooff = 0;
        return () unless (@autos and $autos[0]);
        @autos = map {$_->name()} @autos;
        @currentCompletionList = grep {index($_, $text) == 0} @autos;
    }
    return $currentCompletionList[$count];
}

# completes script name, assume last word is stage, and before that the configuration, and before that might be a distribution.
sub script_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        (my $dist, my $configuration, my $stage) = (split(/\s+/, $currentCommand))[-3..-1];
        $dist = $distribution unless $dist and $db->hasDistribution($dist);
        return () unless $configuration and $stage;
        $echooff = 1;
        (my @scripts) = localgetscripts($configuration, $dist);
        $echooff = 0;
        return () unless (@scripts and $scripts[0]);        
        @scripts = map {$_->name()} grep {$_->stage() eq $stage} @scripts;
        @currentCompletionList = grep {index($_, $text) == 0} @scripts;
    }
    return $currentCompletionList[$count];
}

# completes template name, assume last word is stage, and before that the configuration
sub template_completion {
    my ($text, $count) =@_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        (my $configuration, my $stage) = (split(/\s+/, $currentCommand))[-2..-1];
        return () unless $configuration and $stage;
        $echooff = 1;
        (my @templates) = localgettemplates($configuration);
        $echooff = 0;
        return () unless (@templates and $templates[0]);
        @templates = map {$_->destination()} grep {$_->stage() eq $stage} @templates;
        @currentCompletionList = map {$_ =~ s/ /\\ /g; $_} grep {index($_, $text) == 0} @templates;
    }
    return $currentCompletionList[$count];
}

# complete stage for known scripts, assume last word is a configuration (word before might be a distribution)
sub script_stage_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " "; 
        (my $dist, my $configuration) = (split(/\s+/, $currentCommand))[-2..-1];
        $dist = $distribution unless $dist and $db->hasDistribution($dist);
        return () unless $configuration;
        $echooff = 1;
        (my @scripts) = localgetscripts($configuration, $dist);
        $echooff = 0;
        return () unless (@scripts and $scripts[0]);
        my @stages = map {$_->stage()} @scripts;
        my %stages;
        @stages{@stages} = @stages;
        @stages = sort {$a eq $b ? 0 :
                          $a eq "auto" ? -1 : $b eq "auto" ? 1 :
                            $a eq "mount" ? -1 : $b eq "mount" ? 1 :
                              $a eq "sysinit" ? -1 : 1
                          } keys %stages;
        @currentCompletionList = grep {index($_, $text) == 0} @stages;
    }
    return $currentCompletionList[$count];
}

# complete stage for known templates, assume last word is a configuration
sub template_stage_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " "; 
        my $configuration = (split(/\s+/, $currentCommand))[-1];
        return () unless $configuration;
        $echooff = 1;
        (my @templates) = localgettemplates($configuration);
        $echooff = 0;
        return () unless (@templates and $templates[0]);
        my @stages = map {$_->stage()} @templates;
        my %stages;
        @stages{@stages} = @stages;
        @stages = sort {$a eq $b ? 0 :
                          $a eq "auto" ? -1 : $b eq "auto" ? 1 :
                            $a eq "mount" ? -1 : $b eq "mount" ? 1 :
                              $a eq "sysinit" ? -1 : 1
                          } keys %stages;
        
        @currentCompletionList = grep {index($_, $text) == 0} @stages;
    }
    return $currentCompletionList[$count];
}

# complete stage
sub stage_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = grep {index($_, $text) == 0} qw(auto mount sysinit final);
    }
    return $currentCompletionList[$count];
}

# complete mount, assumes last word was configuration
sub mount_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        @currentCompletionList = ();
        $attribs->{completion_append_character} = " ";
        my $configuration = (split(/\s+/, $currentCommand))[-1];
        return () unless $configuration;
        (my $conf) = $db->getConfigurationsByName($configuration);
        return () unless $conf;
        ($conf) = $db->getFullConfigurations([$conf], $distribution);
        return () unless $conf;
        my @mounts = $db->getMounts($conf);
        return () if @mounts and not defined $mounts[0];

        @currentCompletionList = map {$_->description()} @mounts;
        @currentCompletionList = grep {index($_, $text) == 0} @currentCompletionList;
    }
    return $currentCompletionList[$count];
}

# keep only 1 depth of directory
# input: current text, list to modify
# output: modified list
sub dir_completion_helper {
    my $text = shift;
    my @list = @_;
    unless ($text) {
        # hack for configurations, might start with common/
        if (grep !/^\//, @list) {
            return ("/", "common/");
        } else {
            $text = "/";
        };
    }
    # hack for configurations, might start with c/
    $text = "common/" if (index("common", $text) == 0) and grep m/^common\//, @list;
    (my $basedir, my $filename) = $text =~ m,^(.*?)([^/]+)?$,;
    return () unless $basedir;
    unless ($filename) {
        return grep {$_ =~ m,^${basedir}[^/]*$,} @list;
    }
    return grep {$_ =~ m,^${basedir}${filename}(?:(?:[^/]*)|(?:/[^/]*))$,} @list;
}

# complete a signed directory
sub sign_dir_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = "";
        @currentCompletionList = ();
        if (length($text) < 2) {
            @currentCompletionList = grep {index($_, $text) == 0} qw(+/ -/);
        } else {
            (my $sign, my $halfdir) = $text =~ m,^([+-])(/.*)$,;
            return () unless $sign and $halfdir;
            (my $dir) = $halfdir =~ m,^(.*?/)(?:[^/]+)?$,;
            opendir(DIR, $dir);
            (my @dirs) = grep {$_ ne "." and $_ ne ".." and -d "$dir/$_"} readdir(DIR);
            @dirs = map {fixPath("$dir/$_")} @dirs;
            close(DIR);
            @dirs = grep {index($_, $halfdir) == 0} @dirs;
            @currentCompletionList = map {fixPath("$sign/$_")} @dirs;
        }
    }
    return $currentCompletionList[$count];
}

# complete the command name
sub command_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = grep {index($_, $text) == 0} (keys %commandMap)
    }
    return $currentCompletionList[$count];
}

# complete help topics
sub help_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = grep {index($_, $text) == 0} qw(all distributions hosts groups configurations others);
        push @currentCompletionList, grep {index($_, $text) == 0} (keys %commandMap);
    }
    return $currentCompletionList[$count];
}

# complete configuration and dist, assumes last word was a distribution
sub dist_configuration_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my $dist_name = (split(/\s+/, $currentCommand))[-1];
        return () unless $dist_name;
        my $dist = $db->getDistributionGroup($dist_name);
        return () unless $dist;
        my @configurations = $db->getAllConfigurations($dist_name);
        if (@configurations and not defined $configurations[0]) {
            return ();
        } else {
            @configurations = grep {index($_, $text) == 0} @configurations;
        }
        @currentCompletionList = dir_completion_helper($text, @configurations);
        $attribs->{completion_append_character} = "" if ($#currentCompletionList != $#configurations);
    }
    return $currentCompletionList[$count];
}

# complete configurations
sub configuration_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        unless ($distribution) {
            return ();
        }
        my @configurations = $db->getAllConfigurations($distribution);
        if (@configurations and not defined $configurations[0]) {
            return ();
        } else {
            @configurations = grep {index($_, $text) == 0} @configurations;
        }
        @currentCompletionList = dir_completion_helper($text, @configurations);
        $attribs->{completion_append_character} = "" if ($#currentCompletionList != $#configurations);
    }
    return $currentCompletionList[$count];
}

# complete groups
sub group_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my @groups = $db->getAllGroups();
        if (@groups and not defined $groups[0]) {
            return ();
        } else {
            @groups = grep {index($_, $text) == 0} @groups;
        }
        @currentCompletionList = dir_completion_helper($text, @groups);
        $attribs->{completion_append_character} = "" if ($#currentCompletionList != $#groups);
    }
    return $currentCompletionList[$count];
}

# complete unknown hosts
sub new_host_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        fillDnsHostList() unless @dnsHostList;
        my @hosts = $db->getAllHosts();
        if (@hosts and not defined $hosts[0]) {
            return ();
        }
        my %hosts = ();
        @hosts{@dnsHostList} = @dnsHostList;
        delete @hosts{@hosts};
        @hosts = keys %hosts;
        #@hosts = grep {my $a = $_; not grep {$a eq $_} @hosts} @dnsHostList;
        @currentCompletionList = grep {index($_, $text) == 0} @hosts;
    }
    return $currentCompletionList[$count];
}

# complete hosts
sub host_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my @hosts = $db->getAllHosts();
        if (@hosts and not defined $hosts[0]) {
            return ();
        } else {
            @hosts = grep {index($_, $text) == 0} @hosts;
        }
        @currentCompletionList = @hosts;
    }

    return $currentCompletionList[$count];
}

# complete distribution
sub distribution_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        $attribs->{completion_append_character} = " ";
        @currentCompletionList = ();
        my @distributions = $db->getAllDistributions();
        if (@distributions and not defined $distributions[0]) {
            return ();
        }
        @currentCompletionList = grep {index($_, $text) == 0} @distributions;
    }
    return $currentCompletionList[$count];
}

# complete version
sub version_completion {
    my ($text, $count) = @_;
    if ($count == 0) {
        return $Staple::VERSION if index($Staple::VERSION, $text) == 0;
    }
    return ();
}

sub attempted_completion {
    my ($text, $line, $start, $end) = @_;
    if ($attribs->{gnu_readline_p} and $line =~ m,//,) {
        $line =~ s,/+,/,g;
        Term::ReadLine::Gnu::XS::rl_replace_line("$line", 0);
    }
    $currentCommand = substr($line, 0, $start);
    if (substr($line, 0, $start) =~ /^\s*$/) {
        return $input->completion_matches($text, \&command_completion);
    } else {
        my $parameter = substr($line, 0, $start) =~ s/((^|\s)\S)/$1/g;
        $parameter--;
        (my $command) = $line =~ m/^\s*(\S+)/;
        $command = $commandMap{$command};
        if ($command) {
            my $completions = $commandCompletionMap{$command};
            if ($completions and $completions->[$parameter]) {
                return $input->completion_matches($text, $completions->[$parameter]);
            } else {
                return ();
            }
        }
    }
}

sub setDBHelp {
    my %dbs = listDB();
    delete $dbs{error};
    my $shelp = "
name: sdb | setdb
parameters: <database> [<database specific parameters> ...]

Sets this staplectl session to the given database. There are currently ".scalar(keys %dbs)."
types of databases:

";
    my $nhelp = "
name: ndb | newdb
parameters: <database> [<database specific parameters> ...]

Sets this staplectl session to the given database and create it if necessary
(similar to setdb but creates the database if doesn't exist). There are
currently ".scalar(keys %dbs)." types of databases:

";
    my $i = 1;
    foreach my $db (keys %dbs) {
        my $str .= "$i: $db - $dbs{$db}->{desc}
   $dbs{$db}->{long}

";
        $shelp .= $str;
        $nhelp .= $str;
        $i++;
    }
    $commandsHelp{setdb} = $shelp;
    $commandsHelp{ndb} = $nhelp;
}

sub usage {
    my $exitCode = shift;
    $exitCode = 0 unless $exitCode;
    print "usage: staplectl [options]
options are:
  -h    | --help\t\t Print this help message and exit
        | --color\t\t Colored prompt
  -c    | --command\t Executes the rest of argv as a command and exits
  -dist | --distribution <dist>\t Start with the given distribution
  -db   | --database <db>\t Connects to <db> instead of the default (a Staple::DBFactory::CreateDB parameter).
";
    exit $exitCode;
}

###
#   main
###

my $coloredPrompt;

unless (GetOptions('help|h|?'            => sub {usage(0);},
                   'color!'              => \$coloredPrompt,
                   'c|command'           => \$singleCommand,
                   'dist|distribution=s' => \$distribution,
                   'database|db=s'       => \$db,
                  )) {
    usage(1);
}

$ENV{ANSI_COLORS_DISABLED} = 1;
if ($coloredPrompt) {
    delete $ENV{ANSI_COLORS_DISABLED};
}

$singleCommand = join (" ", @ARGV) if $singleCommand;

setDBHelp();

$distribution = getDistribution() unless ($distribution);
$db = createDB($db ? split /\s+/, $db : undef);
if (not ref $db or $db->{error}) {
    $db = $db->{error} if ref $db;
    perror "$db\n";
    exit 1;
    $db = undef;
    $distribution = undef;
}
if ($db) {
    my @distributions = $db->getAllDistributions();
    unless (not defined $distribution or grep {$_ eq $distribution} @distributions) {
        perror "The $distribution distribution doesn't exist in the current db\n" if $distribution;
        $distribution = undef;
    }
}

if ($singleCommand) {
    (my $command, my @params) = parseline($singleCommand);
    if (grep {$_ eq $command} @singleCommandCommands) {
        $commands{$commandMap{$command}}(@params);
    } else {
        print "\"$command\" can't be executed as a single command (yet)\n";
        exit 1;
    }
} else {
    print "Staple version: $Staple::VERSION\n";
    if ($distribution) {
        print "Starting with distribution:  $distribution\n";
    } else {
        print "Starting without a default distribution\n";
    }
    print "Starting with database: ".$db->info()."\n";

    # set up readline
    $input = new Term::ReadLine 'staplectl';
    $attribs = $input->Attribs;
    if ($ENV{ANSI_COLORS_DISABLED}) {
        $attribs->{term_set}->[0] = '';
        $attribs->{term_set}->[1] = '';
    } else {
        $attribs->{term_set}->[0] = '[32;1m';
        $attribs->{term_set}->[1] = '[0m';
    }
    $attribs->{completion_entry_function} = sub {return ()};
    $attribs->{attempted_completion_function} = \&attempted_completion;
    $input->ReadHistory($historyFile) if -r $historyFile and $attribs->{history_base};

    # main loop
    while (1) {
        my $prompt = $distribution ? "($distribution) staplectl> " : "(UNKNOWN) staplectl> ";
        my $line = $input->readline($prompt);
        next unless $line;
        chomp($line);
        (my $command, my @params) = parseline($line);
        $commands{$commandMap{$command}}(@params);
    }
}

quit;

exit 0;
